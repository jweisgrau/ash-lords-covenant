<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital RPG: Ash-Lord's Covenant</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400&family=IM+Fell+English+SC&family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles.css?v=0.9.4"> 
    
    <style>
        #character-creation-ui, #main-game-ui { display: none; }
        
        #boot-log { 
            font-family: monospace; font-size: 12px; color: #00ff00; 
            background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #333; 
            margin-top: 20px; max-height: 150px; overflow-y: auto; width: 80%; 
            text-align: left; display: none;
        }
        #force-start-btn {
            margin-top: 15px; padding: 10px 20px; background: #8A3324; color: white; 
            border: 1px solid #ff5555; border-radius: 4px; cursor: pointer; font-family: sans-serif; display: none;
        }
    </style>

    <script>
        window.showError = function(title, message) {
            var loader = document.getElementById('loading-overlay');
            if (loader) loader.style.display = 'none';
            
            var modal = document.getElementById('error-modal');
            var mTitle = document.getElementById('error-title');
            var mMsg = document.getElementById('error-message');
            
            if (modal && mTitle && mMsg) {
                mTitle.textContent = title;
                mMsg.textContent = message;
                modal.style.display = 'flex';
            } else {
                console.error("CRITICAL UI FAILURE: " + title + " - " + message);
                if (document.body) {
                    document.body.innerHTML = '<div style="color:red; padding:20px; background:black;"><h1>CRITICAL ERROR</h1><h2>' + title + '</h2><p>' + message + '</p></div>';
                } else {
                    alert("CRITICAL ERROR (DOM Not Ready): " + title + "\n" + message);
                }
            }
        };

        window.addEventListener('error', function(event) {
            try {
                window.showError("Runtime Error", event.message + " at " + event.filename + ":" + event.lineno);
            } catch (e) {
                console.error("Error Handler Failed:", e);
            }
        });
    </script>
</head>
<body class="antialiased">

    <div id="loading-overlay" class="flex fixed top-0 left-0 w-screen h-screen bg-black/80 z-[199] justify-center items-center" style="flex-direction: column;">
        <div class="spinner mb-4"></div>
        <span id="loading-text" class="ml-4 text-lg text-gray-300">Booting v2.3.0 (Equipment & Inventory)...</span>
        <div id="boot-log"></div>
        <button id="force-start-btn" onclick="window.forceUI()">‚ö†Ô∏è FORCE UI</button>
    </div>

    <div id="error-modal" class="fixed top-0 left-0 w-full h-full bg-black/80 z-[200] flex justify-center items-center hidden">
        <div class="modal-content bg-gray-800 border border-gray-700 p-6 rounded-lg max-w-lg w-full">
            <h2 id="error-title" class="text-xl font-bold text-red-400 mb-4">Error</h2>
            <p id="error-message" class="text-gray-300 mb-6 whitespace-pre-wrap font-mono text-sm">Something went wrong.</p>
            <button id="close-modal-btn" onclick="document.getElementById('error-modal').style.display='none'" class="w-full px-4 py-2 bg-emerald-600 text-white rounded-lg font-semibold hover:bg-emerald-700 transition">
                OK
            </button>
        </div>
    </div>

    <div id="toast-container" class="fixed top-4 right-4 z-[200] flex flex-col gap-2 pointer-events-none"></div>

    <div class="container mx-auto max-w-7xl p-4">
        <header class="mb-4 p-4 bg-gray-800 rounded-lg border border-gray-700 flex flex-col sm:flex-row justify-between items-center gap-4">
            <div>
                <h1 class="text-2xl font-bold text-white">Ash-Lord's Covenant</h1>
                <p class="text-sm text-gray-400">Digital RPG Prototype (Build v2.3.0 - Equipment & Inventory System)</p>
            </div>
            <div class="flex items-center space-x-2">
                <button onclick="window.exportSave()" class="px-3 py-2 bg-gray-700 text-xs text-gray-300 rounded-lg hover:bg-emerald-700 hover:text-white transition">
                    Export Save
                </button>
                <button onclick="window.importSave()" class="px-3 py-2 bg-gray-700 text-xs text-gray-300 rounded-lg hover:bg-emerald-700 hover:text-white transition">
                    Import Save
                </button>
                <button id="reset-game-btn" class="px-3 py-2 bg-gray-700 text-xs text-gray-300 rounded-lg hover:bg-red-700 hover:text-white transition">
                    Reset Game
                </button>
            </div>
        </header>

        <div id="character-creation-ui">
            <div class="bg-gray-800 rounded-lg border border-gray-700 shadow-lg p-6 max-w-3xl mx-auto">
                <h2 class="text-3xl font-bold text-white mb-2">Create Your Character</h2>
                <p class="text-gray-400 mb-6">Every hero in this cursed world is defined by what they do (their Calling) and what haunts them (their Burden).</p>
                
                <div class="mb-4">
                    <label for="character-name" class="block text-sm font-medium text-gray-300 mb-1">What is your name?</label>
                    <input type="text" id="character-name" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-gray-200 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h3 class="text-xl font-semibold text-emerald-400 mb-3">Choose a Calling</h3>
                        <div id="calling-options" class="space-y-3"><p class="text-gray-500 italic">Loading data...</p></div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold text-indigo-300 mb-3">Choose a Burden</h3>
                        <div id="burden-options" class="space-y-3"><p class="text-gray-500 italic">Loading data...</p></div>
                        
                        <div id="burden-detail-input-wrapper" class="mt-3" style="display: none;">
                            <label for="burden-detail-input" id="burden-detail-label" class="block text-sm font-medium text-gray-300 mb-1">Define your Burden:</label>
                            <input type="text" id="burden-detail-input" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-gray-200 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                        </div>
                    </div>
                </div>

                <button id="create-character-btn" class="w-full mt-6 px-4 py-3 bg-emerald-700 text-white rounded-lg font-bold hover:bg-emerald-800 shadow-md">
                    Begin Your Story
                </button>
            </div>
        </div>

        <div id="main-game-ui">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                <div id="sidebar-container" class="lg:col-span-1 space-y-4 custom-scrollbar">
                    <div id="character-sheet-wrapper" class="bg-gray-800 rounded-lg border border-gray-700 shadow-lg">
                        <div id="character-sheet-header" class="flex justify-between items-center p-4 border-b border-gray-700 cursor-pointer">
                            <h2 class="text-xl font-semibold text-white">Character Sheet</h2>
                            <svg id="accordion-icon" class="w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                        <div id="character-sheet-content" class="p-4 space-y-4">
                            <p id="character-sheet-loading" class="text-gray-400 italic">Loading character data...</p>
                            <div id="character-sheet-data"></div>
                        </div>
                    </div>

                    <div id="unified-clocks-wrapper" class="bg-gray-800 rounded-lg border border-gray-700 shadow-lg mt-4">
                        <div id="unified-clocks-header" class="flex justify-between items-center p-4 border-b border-gray-700 cursor-pointer hover:bg-gray-750 transition">
                            <h2 class="text-xl font-semibold text-white">World State</h2>
                            <svg id="unified-accordion-icon" class="w-6 h-6 text-gray-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>

                        <div id="unified-clocks-content" class="p-4 space-y-6">
                            <div class="grid grid-cols-2 gap-2 border-b-spacers pb-8 mb-6"> 
                                <div class="flex flex-col items-center">
                                    <h4 class="text-xs uppercase text-emerald-400 font-bold tracking-wider mb-2">DESTINY</h4>
                                    <div class="clock transform scale-90">
                                        <div class="clock-face" id="destiny-clock-face"></div>
                                    </div>
                                    <p id="destiny-narrative" class="text-xs text-gray-400 text-center mt-2 font-mono leading-tight px-1">Your destiny awaits...</p>
                                </div>
                                <div class="flex flex-col items-center pl-2">
                                    <h4 class="text-xs uppercase text-red-400 font-bold tracking-wider mb-2">THE THREAT</h4>
                                    <div class="clock transform scale-90">
                                        <div class="clock-face" id="endgame-front-clock-face"></div> 
                                    </div>
                                    <span id="endgame-front-name" class="text-xs text-gray-400 text-center mt-2 font-mono leading-tight">Unknown Threat</span>
                                </div>
                            </div>

                            <div class="pt-2">
                                <h4 class="text-xs uppercase text-gray-500 mb-3 text-center font-bold tracking-widest">FACTION ACTIVITY</h4>
                                <div id="world-clocks-container" class="grid grid-cols-2 gap-4">
                                    <p id="world-clocks-loading" class="text-gray-400 italic col-span-2 text-center text-xs">Loading world state...</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="quest-progress-wrapper" class="bg-gray-800 rounded-lg border border-gray-700 shadow-lg p-4" style="display: none;">
                        <h2 class="text-xl font-semibold text-emerald-400 mb-2">Active Quest</h2>
                        <div id="quest-progress-content">
                            <p id="quest-title" class="font-bold text-white text-lg mb-1"></p>
                            <p id="quest-chapter" class="text-sm text-gray-400 mb-2"></p>
                            <div class="bg-gray-900 rounded p-2">
                                <div class="flex justify-between text-xs text-gray-400 mb-1">
                                    <span>Progress</span>
                                    <span id="quest-progress-text">0/0</span>
                                </div>
                                <div class="w-full bg-gray-700 rounded-full h-2">
                                    <div id="quest-progress-bar" class="bg-emerald-600 h-2 rounded-full transition-all" style="width: 0%"></div>
                                </div>
                            </div>
                            <p id="quest-xp-earned" class="text-xs text-gray-400 mt-2"></p>
                        </div>
                    </div>
                </div>

                <div class="lg:col-span-2 flex flex-col h-[80vh]">
                    <div class="flex-grow bg-gray-800 rounded-lg border border-gray-700 shadow-lg p-4 overflow-y-auto" id="narrative-log"></div>

                    <div id="interaction-panel" class="mt-4 bg-gray-800 rounded-lg border border-gray-700 shadow-lg p-4">
                        <div id="chapter-phase-ui">
                            <textarea id="player-input" 
                                      class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-gray-200 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500" 
                                      rows="3" 
                                      placeholder="Describe your character's action..."></textarea>
                            
                            <button id="submit-action-btn" class="w-full mt-3 px-4 py-3 bg-emerald-700 text-white rounded-lg font-bold hover:bg-emerald-800 shadow-md">
                                Submit Action
                            </button>
                            
                            <p class="text-xs text-gray-500 text-center mt-2">Press <kbd class="px-1 bg-gray-700 rounded">Enter</kbd> to submit (Shift+Enter for new line)</p>
                        </div>
                        
                        <div id="interlude-phase-ui" class="hidden">
                            <div class="mb-4 p-3 bg-gray-900 rounded-lg border border-emerald-700">
                                <h3 class="text-lg font-bold text-emerald-400 mb-2">‚è≥ Downtime Phase</h3>
                                <p class="text-sm text-gray-400">The world moves on while you rest. Faction clocks advance. Choose how to spend your time wisely.</p>
                            </div>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                                <button id="interlude-train-btn" class="interlude-button flex flex-col items-start text-left p-3">
                                    <span class="font-bold text-white">Seek Training (1 XP)</span>
                                    <span class="text-xs text-gray-400 mt-1">Study under a mentor. Gain insight or skill.</span>
                                </button>
                                <button id="interlude-asset-btn" class="interlude-button flex flex-col items-start text-left p-3">
                                    <span class="font-bold text-white">Acquire an Asset (1 XP)</span>
                                    <span class="text-xs text-gray-400 mt-1">Find equipment, allies, or information.</span>
                                </button>
                                <button id="interlude-reflect-btn" class="interlude-button flex flex-col items-start text-left p-3">
                                    <span class="font-bold text-white">Reflect & Integrate (1 XP)</span>
                                    <span class="text-xs text-gray-400 mt-1">Process experiences. Potentially gain a Tag.</span>
                                </button>
                                <button id="interlude-heal-btn" class="interlude-button flex flex-col items-start text-left p-3">
                                    <span class="font-bold text-white">Rest & Recover (3 Coin)</span>
                                    <span class="text-xs text-gray-400 mt-1">Heal one Pip of damage. Requires coin.</span>
                                </button>
                                <button id="interlude-shop-btn" class="interlude-button flex flex-col items-start text-left p-3 border-amber-700">
                                    <span class="font-bold text-amber-400">Visit Equipment Shop (5 XP)</span>
                                    <span class="text-xs text-gray-400 mt-1">Purchase specialized tools or armor.</span>
                                </button>
                                <button id="interlude-repair-btn" class="interlude-button flex flex-col items-start text-left p-3 border-blue-700">
                                    <span class="font-bold text-blue-400">Repair Armor (Free)</span>
                                    <span class="text-xs text-gray-400 mt-1">Restore all armor to full protection.</span>
                                </button>
                            </div>
                            <button id="interlude-end-btn" class="w-full mt-4 px-4 py-3 bg-red-900 text-white rounded-lg font-bold hover:bg-red-800 transition border border-red-700">
                                Return to Adventure ‚Üí
                            </button>
                            <p class="text-xs text-gray-500 text-center mt-2">Warning: Ending downtime advances faction clocks!</p>
                        </div>

                        <!-- XP Shop Modal -->
                        <div id="xp-shop-modal" class="fixed top-0 left-0 w-full h-full bg-black/80 z-[200] flex justify-center items-center hidden">
                            <div class="modal-content bg-gray-800 border border-amber-700 p-6 rounded-lg max-w-lg w-full">
                                <h2 class="text-xl font-bold text-amber-400 mb-4">‚öîÔ∏è Equipment Shop</h2>
                                <p class="text-gray-400 text-sm mb-4">Spend 5 XP to purchase specialized gear. Choose wisely - only 3 items available per visit.</p>
                                <div id="xp-shop-items" class="space-y-3 mb-4">
                                    <!-- Items will be populated by JavaScript -->
                                </div>
                                <button id="xp-shop-close-btn" class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg font-semibold hover:bg-gray-600 transition">
                                    Close Shop
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load game data first (no module required) -->
    <script src="./game_data.js"></script>

    <script>
        // ===== STATE MANAGER (Inlined for local file:// compatibility) =====

        const GAME_STATE_KEY = "ashlords_game_v1";
        const BACKUP_KEY = "ashlords_game_v1_backup";

        const createFreshState = () => ({
            version: "2.3.0",
            userId: `local-${crypto.randomUUID()}`,
            character: null,
            gameState: {
                phase: "character_creation",  // character_creation, adventure, downtime
                turn_count: 0,
                adventure_turn_count: 0,      // Turns since last downtime
                saga_log: "The story begins...",
                current_location: "Unknown"
            },
            chatHistory: [],
            worldClocks: { clocks: [] },
            destinyFrontClocks: {
                destiny: { current: 0, segments: 8 },
                front: { current: 0, segments: 8, name: "The Threat Looms" }
            },
            // Hidden progress clocks (not shown to player directly)
            progressClocks: [],
            // Tags - narrative facts about the character
            tags: [],
            questState: { current_quest: null },
            campaign: null
        });

        class StateValidator {
            static validate(updates, currentState) {
                const errors = [];
                if (updates.character) {
                    const char = updates.character;
                    if (char.stats) {
                        for (const [stat, val] of Object.entries(char.stats)) {
                            if (val < -1 || val > 5) {
                                errors.push(`Stat ${stat} out of bounds: ${val}`);
                            }
                        }
                    }
                    if (char.pips) {
                        for (const [stat, pips] of Object.entries(char.pips)) {
                            if (pips < 0 || pips > 2) {
                                errors.push(`Pips ${stat} out of bounds: ${pips}`);
                            }
                        }
                    }
                    if (char.currency !== undefined && char.currency < 0) {
                        errors.push(`Currency cannot be negative: ${char.currency}`);
                    }
                    if (char.xp !== undefined && char.xp < 0) {
                        errors.push(`XP cannot be negative: ${char.xp}`);
                    }
                }
                if (updates.chatHistory && updates.chatHistory.length > 30) {
                    errors.push(`Chat history exceeds 30 messages`);
                }
                if (errors.length > 0) {
                    throw new Error("Validation failed:\n" + errors.join("\n"));
                }
                return true;
            }
        }

        class ErrorRecovery {
            static recoverState() {
                try {
                    const stateStr = localStorage.getItem(GAME_STATE_KEY);
                    if (stateStr) {
                        const state = JSON.parse(stateStr);
                        if (this.validateStructure(state)) {
                            console.log("‚úÖ Loaded state from localStorage");
                            return state;
                        }
                    }
                } catch (e) {
                    console.error("‚ùå Main state corrupted:", e);
                }
                try {
                    const backupStr = localStorage.getItem(BACKUP_KEY);
                    if (backupStr) {
                        const backup = JSON.parse(backupStr);
                        if (this.validateStructure(backup)) {
                            console.warn("‚ö†Ô∏è Recovered from backup state");
                            return backup;
                        }
                    }
                } catch (e) {
                    console.error("‚ùå Backup state corrupted:", e);
                }
                console.log("üÜï Creating fresh state");
                return createFreshState();
            }

            static validateStructure(state) {
                return state && state.version && state.userId && state.gameState && Array.isArray(state.chatHistory);
            }

            static createBackup(state) {
                try {
                    localStorage.setItem(BACKUP_KEY, JSON.stringify(state));
                } catch (e) {
                    console.error("Failed to create backup:", e);
                }
            }
        }

        class TransactionQueue {
            constructor(stateManager) {
                this.stateManager = stateManager;
                this.queue = [];
                this.processing = false;
            }

            async enqueue(transaction) {
                return new Promise((resolve, reject) => {
                    this.queue.push({ transaction, resolve, reject });
                    this.processNext();
                });
            }

            async processNext() {
                if (this.processing || this.queue.length === 0) return;
                this.processing = true;
                const { transaction, resolve, reject } = this.queue.shift();
                try {
                    const updates = await transaction(this.stateManager.state);
                    const result = await this.stateManager.updateState(updates);
                    resolve(result);
                } catch (error) {
                    console.error("Transaction failed:", error);
                    reject(error);
                } finally {
                    this.processing = false;
                    this.processNext();
                }
            }
        }

        class GameStateManager {
            constructor() {
                this.state = ErrorRecovery.recoverState();
                this.listeners = new Map();
                this.txQueue = new TransactionQueue(this);
                ErrorRecovery.createBackup(this.state);
            }

            subscribe(key, callback) {
                if (!this.listeners.has(key)) {
                    this.listeners.set(key, new Set());
                }
                this.listeners.get(key).add(callback);
                // Always call callback immediately with current state (even if null)
                const slice = this.getStateSlice(key);
                callback(slice);
            }

            unsubscribe(key, callback) {
                this.listeners.get(key)?.delete(callback);
            }

            async updateState(updates) {
                try {
                    StateValidator.validate(updates, this.state);
                    const newState = this.deepMerge(this.state, updates);
                    localStorage.setItem(GAME_STATE_KEY, JSON.stringify(newState));
                    if (newState.gameState?.turn_count % 5 === 0) {
                        ErrorRecovery.createBackup(newState);
                    }
                    this.state = newState;
                    this.notifySubscribers(updates);
                    return { success: true };
                } catch (error) {
                    console.error("State update failed:", error);
                    return { success: false, error: error.message };
                }
            }

            deepMerge(target, source) {
                const output = { ...target };
                for (const key in source) {
                    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                        output[key] = this.deepMerge(target[key] || {}, source[key]);
                    } else {
                        output[key] = source[key];
                    }
                }
                return output;
            }

            notifySubscribers(updates) {
                for (const [key, callbacks] of this.listeners) {
                    if (this.wasKeyAffected(key, updates)) {
                        const slice = this.getStateSlice(key);
                        callbacks.forEach(cb => {
                            try { cb(slice); } catch (e) { console.error(`Listener error for ${key}:`, e); }
                        });
                    }
                }
            }

            wasKeyAffected(key, updates) {
                return key in updates || key === 'all';
            }

            getStateSlice(key) {
                switch(key) {
                    case 'character': return this.state.character;
                    case 'chatHistory': return this.state.chatHistory;
                    case 'worldClocks': return this.state.worldClocks;
                    case 'destinyFrontClocks': return this.state.destinyFrontClocks;
                    case 'gameState': return this.state.gameState;
                    case 'questState': return this.state.questState;
                    case 'all': return this.state;
                    default: return null;
                }
            }

            getState() { return this.state; }
            async transaction(fn) { return this.txQueue.enqueue(fn); }
            exportState() { return JSON.stringify(this.state, null, 2); }

            importState(stateJson) {
                try {
                    const imported = JSON.parse(stateJson);
                    if (ErrorRecovery.validateStructure(imported)) {
                        this.state = imported;
                        localStorage.setItem(GAME_STATE_KEY, stateJson);
                        ErrorRecovery.createBackup(imported);
                        this.notifySubscribers({ all: true });
                        return true;
                    }
                    return false;
                } catch (e) {
                    console.error("Import failed:", e);
                    return false;
                }
            }

            reset() {
                this.state = createFreshState();
                localStorage.setItem(GAME_STATE_KEY, JSON.stringify(this.state));
                localStorage.removeItem(BACKUP_KEY);
                this.notifySubscribers({ all: true });
            }
        }

        const gameState = new GameStateManager();

        // ===== INVENTORY SYSTEM (Equipment Management) =====

        const InventorySystem = {
            // Get tool bonus for a stat (returns 0 or 1)
            getToolBonus(stat) {
                const character = gameState.getState().character;
                if (!character) return 0;
                const tool = (character.equipment || []).find(
                    i => i.type === 'tool' && i.stat === stat
                );
                return tool ? (tool.bonus || 1) : 0;
            },

            // Get available armor pips for a stat
            getArmorPips(stat) {
                const character = gameState.getState().character;
                if (!character) return 0;
                const armor = (character.equipment || []).find(
                    i => i.type === 'armor' && i.stat === stat
                );
                return armor ? (armor.pips || 0) : 0;
            },

            // Damage armor before character takes pips - returns remaining damage
            async damageArmor(stat, amount) {
                const character = gameState.getState().character;
                if (!character) return amount;

                const equipment = character.equipment || [];
                const armorIndex = equipment.findIndex(
                    i => i.type === 'armor' && i.stat === stat && (i.pips || 0) > 0
                );

                if (armorIndex === -1) return amount; // No armor to absorb

                const armor = equipment[armorIndex];
                const absorbed = Math.min(armor.pips, amount);
                const remaining = amount - absorbed;

                // Update armor pips
                const newEquipment = [...equipment];
                newEquipment[armorIndex] = { ...armor, pips: armor.pips - absorbed };

                await gameState.transaction(async (state) => ({
                    character: {
                        ...state.character,
                        equipment: newEquipment
                    }
                }));

                if (absorbed > 0) {
                    showToast(`${armor.name} absorbs ${absorbed} damage!`);
                }

                return remaining;
            },

            // Repair all armor during downtime
            async repairAllArmor() {
                const character = gameState.getState().character;
                if (!character) return;

                const equipment = character.equipment || [];
                let repairedAny = false;

                const repairedEquipment = equipment.map(item => {
                    if (item.type === 'armor' && item.pips < (item.max_pips || 2)) {
                        repairedAny = true;
                        return { ...item, pips: item.max_pips || 2 };
                    }
                    return item;
                });

                if (repairedAny) {
                    await gameState.transaction(async (state) => ({
                        character: {
                            ...state.character,
                            equipment: repairedEquipment
                        }
                    }));
                    showToast('All armor repaired!');
                }
            },

            // Add item to inventory
            async addItem(item) {
                const character = gameState.getState().character;
                if (!character) return false;

                // For tools/armor, check if we already have one for that stat
                if (item.type === 'tool' || item.type === 'armor') {
                    const existing = (character.equipment || []).find(
                        i => i.type === item.type && i.stat === item.stat
                    );
                    if (existing) {
                        showToast(`Already have a ${item.stat} ${item.type}!`);
                        return false;
                    }
                }

                // Prepare item with proper structure
                const newItem = {
                    name: item.name,
                    type: item.type || 'loot',
                    properties: item.properties || [],
                    lore: item.lore || item.desc || '',
                    ...(item.type === 'tool' ? { stat: item.stat, bonus: item.bonus || 1 } : {}),
                    ...(item.type === 'armor' ? { stat: item.stat, pips: item.max_pips || 2, max_pips: item.max_pips || 2 } : {}),
                    ...(item.tags ? { tags: item.tags } : {}),
                    ...(item.desc ? { desc: item.desc } : {})
                };

                await gameState.transaction(async (state) => ({
                    character: {
                        ...state.character,
                        equipment: [...(state.character.equipment || []), newItem]
                    }
                }));

                showToast(`+1 Item: ${item.name}`);
                return true;
            },

            // Remove item by name
            async removeItem(itemName) {
                const character = gameState.getState().character;
                if (!character) return false;

                const equipment = character.equipment || [];
                const index = equipment.findIndex(i => i.name === itemName);
                if (index === -1) return false;

                const newEquipment = [...equipment];
                newEquipment.splice(index, 1);

                await gameState.transaction(async (state) => ({
                    character: {
                        ...state.character,
                        equipment: newEquipment
                    }
                }));

                showToast(`Removed: ${itemName}`);
                return true;
            },

            // Check if character has an item
            hasItem(itemName) {
                const character = gameState.getState().character;
                if (!character) return false;
                return (character.equipment || []).some(i => i.name === itemName);
            },

            // Get all equipment of a type
            getEquipmentByType(type) {
                const character = gameState.getState().character;
                if (!character) return [];
                return (character.equipment || []).filter(i => i.type === type);
            },

            // Get 3 random items from MASTER_GEAR_LIST that player doesn't own
            getAvailableShopItems(count = 3) {
                const character = gameState.getState().character;
                if (!character || !CONTENT_PACK_ASHLORDS.MASTER_GEAR_LIST) return [];

                const owned = (character.equipment || []).map(e => e.name);
                const available = CONTENT_PACK_ASHLORDS.MASTER_GEAR_LIST.filter(
                    item => !owned.includes(item.name)
                );

                // Shuffle and pick
                const shuffled = [...available].sort(() => Math.random() - 0.5);
                return shuffled.slice(0, count);
            }
        };

        // ===== MECHANICS ENGINE (Client-Side) =====

        const MechanicsEngine = {
            // Parse player intent from text input
            // Priority: Check for ACTION VERBS first (anywhere in text), then fall back to narrative
            parseIntent(input) {
                const lower = input.toLowerCase().trim();

                // === PRIORITY 1: Check for action verbs ANYWHERE in the input ===

                // Combat - always Tier 2 (check first as it's highest stakes)
                if (/attack|fight|strike|hit|kill|stab|slash|punch|kick|shoot|throw.*(at|toward)|battle|duel|assault/.test(lower)) {
                    return { needsRoll: true, stat: 'FORCE', tier: 2, type: 'combat' };
                }

                // Stealing/Pickpocketing - gives loot on success (check BEFORE general stealth)
                if (/pickpocket|steal|pilfer|filch|swipe|lift|loot|rob|take.*(coin|gold|money|purse|wallet|pouch)/.test(lower)) {
                    return { needsRoll: true, stat: 'FINESSE', tier: 1, type: 'steal' };
                }

                // General Stealth/Finesse - no automatic loot
                if (/sneak|hide|stealth|creep|shadow|pick.*(lock)|climb|dodge|evade|escape|slip/.test(lower)) {
                    return { needsRoll: true, stat: 'FINESSE', tier: 1, type: 'stealth' };
                }

                // Social/Influence - hostile = Tier 2
                if (/persuade|convince|negotiate|bribe|charm|seduce|intimidate|threaten|lie|deceive|bluff|manipulate|coerce/.test(lower)) {
                    const isHostile = /threaten|intimidate|hostile|angry|suspicious|coerce/.test(lower);
                    return { needsRoll: true, stat: 'INFLUENCE', tier: isHostile ? 2 : 1, type: 'social' };
                }

                // Investigation/Wits
                if (/search|investigate|find|discover|figure|solve|deduce|analyze|study|research|recall|remember|examine.*(closely|carefully)|inspect/.test(lower)) {
                    return { needsRoll: true, stat: 'WITS', tier: 1, type: 'investigate' };
                }

                // Endurance/Resolve
                if (/endure|resist|withstand|brave|courage|face.*(fear|horror)|push through|keep going/.test(lower)) {
                    return { needsRoll: true, stat: 'RESOLVE', tier: 1, type: 'endurance' };
                }

                // === PRIORITY 2: No action verbs found - check for narrative/dialogue ===

                // Simple observation (no hidden search intent)
                if (/^(look at|examine|observe|watch|look around)/.test(lower) && !/search|find|hidden|closely|carefully/.test(lower)) {
                    return { needsRoll: false, type: 'narrative' };
                }

                // Simple dialogue (no persuasion intent)
                if (/^(ask|talk|speak|say|tell|greet|chat)/.test(lower) && !/persuade|convince|lie|threaten/.test(lower)) {
                    return { needsRoll: false, type: 'dialogue' };
                }

                // Pure movement/waiting (ONLY if no other action verbs)
                if (/^(walk|leave|go|move|exit|enter|wait|rest|sleep)\b/.test(lower)) {
                    return { needsRoll: false, type: 'narrative' };
                }

                // Default: ambiguous - will ask AI to classify or default to narrative
                return { needsRoll: false, type: 'narrative', ambiguous: true };
            },

            // Roll dice and calculate outcome
            rollDice(stat, tier, character) {
                const d10 = Math.floor(Math.random() * 10) + 1;
                const statMod = character.stats[stat] || 0;
                const pips = character.pips?.[stat] || 0;
                // Add tool bonus from equipment
                const toolBonus = InventorySystem.getToolBonus(stat);
                const total = d10 + statMod + toolBonus - pips;

                let outcome;
                if (tier === 1) {
                    // Tier 1: 8+ Success, 5-7 Cost, 4- Miss
                    if (total >= 8) outcome = 'success';
                    else if (total >= 5) outcome = 'cost';
                    else outcome = 'miss';
                } else {
                    // Tier 2: 11+ Full Success, 8-10 Minor Cost, 6-7 Major Cost, 5- Failure
                    if (total >= 11) outcome = 'success';
                    else if (total >= 8) outcome = 'minor_cost';
                    else if (total >= 6) outcome = 'major_cost';
                    else outcome = 'miss';
                }

                return { d10, statMod, pips, toolBonus, total, outcome, stat, tier };
            },


            // Apply consequences to game state
            async applyConsequences(consequences) {
                // Handle damage with armor absorption first
                if (consequences.add_pips) {
                    const stat = consequences.add_pips.stat;
                    let damageAmount = consequences.add_pips.amount;

                    // Try to absorb damage with armor first
                    damageAmount = await InventorySystem.damageArmor(stat, damageAmount);

                    // Apply remaining damage to character pips
                    if (damageAmount > 0) {
                        await gameState.transaction(async (state) => {
                            const character = state.character;
                            const currentPips = { ...(character.pips || {}) };
                            currentPips[stat] = Math.min(2, (currentPips[stat] || 0) + damageAmount);
                            return {
                                character: {
                                    ...character,
                                    pips: currentPips
                                }
                            };
                        });
                        showToast(`${stat} damage: +${damageAmount} pip${damageAmount > 1 ? 's' : ''}`);
                    }
                }

                // Handle XP and currency gains
                await gameState.transaction(async (state) => {
                    const updates = {};
                    const character = state.character;

                    if (consequences.xp_gain > 0) {
                        updates.character = {
                            ...character,
                            xp: (character.xp || 0) + consequences.xp_gain
                        };
                        showToast(`+${consequences.xp_gain} XP`);
                    }

                    if (consequences.currency_gain !== 0) {
                        const newCurrency = Math.max(0, (character.currency || 0) + consequences.currency_gain);
                        updates.character = {
                            ...(updates.character || character),
                            currency: newCurrency
                        };
                        showToast(`${consequences.currency_gain > 0 ? '+' : ''}${consequences.currency_gain} Coin`);
                    }

                    return updates;
                });
            },

            // Escalation Oracle (1d6) - determines complication severity on Cost
            rollEscalationOracle() {
                const d6 = Math.floor(Math.random() * 6) + 1;
                let result;

                if (d6 <= 4) {
                    // 1-4: Minor Twist (Tier 1 complication)
                    result = {
                        type: 'minor_twist',
                        description: 'Minor complication',
                        advanceThreat: false
                    };
                } else if (d6 === 5) {
                    // 5: Minor Twist + Advance Threat Clock
                    result = {
                        type: 'minor_threat',
                        description: 'Minor complication + threat advances',
                        advanceThreat: true
                    };
                } else {
                    // 6: Major Oracle Twist (Tier 2 complication)
                    result = {
                        type: 'major_twist',
                        description: 'Major complication!',
                        advanceThreat: false
                    };
                }

                return { d6, ...result };
            },

            // Enhanced consequence calculation with Escalation Oracle + Oracle Tables
            // Tier 1: success/cost/miss | Tier 2: success/minor_cost/major_cost/miss
            getConsequences(rollResult, actionType) {
                const consequences = {
                    xp_gain: 0,
                    currency_gain: 0,
                    add_pips: null,
                    escalation: null,
                    twist: null,  // Oracle-generated twist for AI narrative
                    description: '',
                    stealContext: actionType === 'steal'  // Flag for AI to know stealing occurred
                };

                if (rollResult.outcome === 'success') {
                    consequences.xp_gain = 1;
                    // For steal: AI will determine loot based on context
                    if (actionType === 'steal') {
                        consequences.description = 'Success! The AI will describe what was stolen based on the target.';
                    } else {
                        consequences.description = 'Success!';
                    }
                } else if (rollResult.outcome === 'cost' || rollResult.outcome === 'minor_cost') {
                    // Tier 1 cost OR Tier 2 minor cost: Success + minor twist
                    consequences.xp_gain = 1;

                    // Roll minor twist from Oracle
                    const minorTwist = OracleSystem.rollMinorTwist();
                    consequences.twist = minorTwist;

                    // For steal on cost: partial success, AI decides reduced loot
                    if (actionType === 'steal') {
                        consequences.description = `Success with complication! Partial loot - AI describes what was grabbed.`;
                    } else {
                        consequences.description = `Success with minor complication`;
                    }
                } else if (rollResult.outcome === 'major_cost') {
                    // Tier 2 major cost: Success + major twist + pip damage
                    consequences.xp_gain = 1;

                    // Roll major twist from Oracle
                    const majorTwist = OracleSystem.rollMajorTwist();
                    consequences.twist = majorTwist;

                    // Major cost always includes pip damage
                    consequences.add_pips = { stat: rollResult.stat, amount: 1 };

                    if (actionType === 'steal') {
                        consequences.description = `Success with major complication! Partial loot + injury.`;
                    } else {
                        consequences.description = `Success with major complication and injury`;
                    }
                } else { // miss
                    // Tier 2 failures still award XP (learning from failure)
                    if (rollResult.tier === 2) {
                        consequences.xp_gain = 1;
                    }

                    const severity = (rollResult.tier === 2 || actionType === 'combat') ? 2 : 1;
                    consequences.add_pips = { stat: rollResult.stat, amount: severity };

                    // Get injury flavor text from Oracle
                    const flavor = OracleSystem.getInjuryFlavor(rollResult.stat, severity);
                    consequences.description = severity >= 2
                        ? `Failure with serious injury: ${flavor}`
                        : `Failure with strain: ${flavor}`;

                    // No loot on miss for steal
                    if (actionType === 'steal') {
                        consequences.description += ` (No loot obtained)`;
                    }
                }

                return consequences;
            },

            // Format roll result for display and AI context
            formatRollResult(rollResult) {
                if (!rollResult) return '';
                const { d10, stat, statMod, pips, toolBonus, total, outcome, tier } = rollResult;
                const tierLabel = tier === 2 ? 'Perilous' : 'Challenging';
                const pipText = pips > 0 ? ` - ${pips}(Pips)` : '';
                const toolText = toolBonus > 0 ? ` + ${toolBonus}(Tool)` : '';
                const outcomeLabel = outcome === 'minor_cost' ? 'MINOR COST' :
                                    outcome === 'major_cost' ? 'MAJOR COST' : outcome.toUpperCase();
                return `Action: ${stat} (Tier ${tier} - ${tierLabel}). Roll: d10(${d10}) + ${statMod}(${stat})${toolText}${pipText} = ${total}. Result: ${outcomeLabel}`;
            }
        };

        // ===== ORACLE SYSTEM (Deterministic Complication Generation) =====

        const OracleSystem = {
            // Roll from Tier 1 Minor Twist tables (returns category and description)
            rollMinorTwist() {
                const twists = CONTENT_PACK_ASHLORDS.TIER_1_TWISTS;
                const categories = Object.keys(twists);
                const category = categories[Math.floor(Math.random() * categories.length)];
                const table = twists[category];
                const entry = table[Math.floor(Math.random() * table.length)];
                return {
                    category,
                    description: entry,
                    type: 'minor'
                };
            },

            // Roll from Tier 2 Major Twist table (witty grimdark)
            rollMajorTwist() {
                const table = CONTENT_PACK_ASHLORDS.TIER_2_TWISTS_WITTY;
                const entry = table[Math.floor(Math.random() * table.length)];
                return {
                    complication: entry.complication,
                    twist: entry.twist,
                    description: `${entry.complication} ${entry.twist}`,
                    type: 'major'
                };
            },

            // Roll Core Oracle (Action + Theme combination)
            rollCoreOracle() {
                const actions = CONTENT_PACK_ASHLORDS.ORACLES.ACTIONS;
                const themes = CONTENT_PACK_ASHLORDS.ORACLES.THEMES;
                return {
                    action: actions[Math.floor(Math.random() * actions.length)],
                    theme: themes[Math.floor(Math.random() * themes.length)]
                };
            },

            // Roll a location from the oracle
            rollLocation() {
                const locations = CONTENT_PACK_ASHLORDS.ORACLES.LOCATIONS;
                return locations[Math.floor(Math.random() * locations.length)];
            },

            // Get a quest hook with engine-switch reveal
            rollQuestHook() {
                const hooks = CONTENT_PACK_ASHLORDS.QUEST_HOOKS;
                return hooks[Math.floor(Math.random() * hooks.length)];
            },

            // Get injury flavor text based on stat and severity
            getInjuryFlavor(stat, severity) {
                const flavor = INJURY_FLAVOR_TEXT[stat];
                if (!flavor) return severity >= 2 ? "Serious wound" : "Minor strain";
                return severity >= 2 ? flavor.injury : flavor.strain;
            },

            // Format twist for display
            formatTwist(twist) {
                if (!twist) return '';
                if (twist.type === 'major') {
                    return `MAJOR COMPLICATION: ${twist.description}`;
                }
                return `Complication (${twist.category.replace(/_/g, ' ')}): ${twist.description}`;
            }
        };

        // ===== WORLD TURN & PHASE MANAGEMENT =====

        const WorldTurn = {
            // Execute World Turn during Downtime
            // Advances faction clocks and triggers Grim Portents
            async execute() {
                const state = gameState.getState();
                const worldClocks = state.worldClocks?.clocks || [];
                const updates = [];
                const portents = [];

                // Advance each faction clock by 1
                for (const clock of worldClocks) {
                    const newCurrent = Math.min(clock.segments, (clock.current || 0) + 1);

                    // Check if clock just filled
                    if (newCurrent >= clock.segments && clock.current < clock.segments) {
                        portents.push({
                            faction: clock.name,
                            event: `The ${clock.name} have achieved their goal: ${clock.goal || 'Advance Agenda'}!`
                        });
                    }

                    updates.push({
                        ...clock,
                        current: newCurrent
                    });
                }

                // Update world clocks
                await gameState.transaction(async (state) => ({
                    worldClocks: { clocks: updates }
                }));

                // Return portents for narrative
                return portents;
            },

            // Check if downtime should trigger (every 5 adventure turns or after major event)
            shouldTriggerDowntime(state) {
                const turnsSinceDowntime = state.gameState?.adventure_turn_count || 0;

                // Check for injury threshold (any stat at 2 pips)
                const hasSerious = Object.values(state.character?.pips || {}).some(p => p >= 2);

                // Trigger downtime after 5 turns OR if seriously injured
                return turnsSinceDowntime >= 5 || hasSerious;
            },

            // Generate World Turn narrative for AI
            async generateWorldTurnNarrative(portents) {
                if (portents.length === 0) {
                    return "The factions continue their machinations in the shadows...";
                }

                return portents.map(p => p.event).join('\n\n');
            }
        };

        // ===== TAG SYSTEM =====

        const TagSystem = {
            // Add a tag to the character
            async addTag(tag) {
                await gameState.transaction(async (state) => {
                    const tags = [...(state.tags || [])];
                    // Avoid duplicates
                    if (!tags.find(t => t.name === tag.name)) {
                        tags.push({
                            name: tag.name,
                            type: tag.type || 'story',  // 'story', 'reputation', 'relationship', 'secret'
                            description: tag.description || '',
                            acquired_turn: state.gameState?.turn_count || 0
                        });
                    }
                    return { tags };
                });
                showToast(`New Tag: ${tag.name}`);
            },

            // Remove a tag
            async removeTag(tagName) {
                await gameState.transaction(async (state) => {
                    const tags = (state.tags || []).filter(t => t.name !== tagName);
                    return { tags };
                });
            },

            // Get tags for AI context
            getTagsContext(state) {
                const tags = state.tags || [];
                if (tags.length === 0) return "None yet.";
                return tags.map(t => `‚Ä¢ ${t.name} (${t.type}): ${t.description}`).join('\n');
            }
        };

        // ===== PROGRESS CLOCK SYSTEM (Hidden from player) =====

        const ProgressClockSystem = {
            // Create a new hidden progress clock
            async createClock(name, segments = 6, type = 'threat') {
                await gameState.transaction(async (state) => {
                    const clocks = [...(state.progressClocks || [])];
                    clocks.push({
                        name,
                        segments,
                        current: 0,
                        type,  // 'threat', 'opportunity', 'countdown'
                        created_turn: state.gameState?.turn_count || 0
                    });
                    return { progressClocks: clocks };
                });
            },

            // Advance a progress clock
            async advanceClock(name, amount = 1) {
                let triggered = false;
                await gameState.transaction(async (state) => {
                    const clocks = (state.progressClocks || []).map(c => {
                        if (c.name === name) {
                            const newCurrent = Math.min(c.segments, (c.current || 0) + amount);
                            if (newCurrent >= c.segments) {
                                triggered = true;
                            }
                            return { ...c, current: newCurrent };
                        }
                        return c;
                    });
                    return { progressClocks: clocks };
                });
                return triggered;
            },

            // Remove a completed clock
            async removeClock(name) {
                await gameState.transaction(async (state) => {
                    const clocks = (state.progressClocks || []).filter(c => c.name !== name);
                    return { progressClocks: clocks };
                });
            }
        };

        // ===== GAME CODE =====
        // Note: CONTENT_PACK_ASHLORDS is loaded from game_data.js script tag

        const ui = {}; 

        function logBoot(msg) {
            console.log(msg);
            const el = document.getElementById('boot-log');
            if(el) {
                el.style.display = 'block';
                el.innerHTML += `<div>> ${msg}</div>`;
            }
        }

        async function init() {
            logBoot("üöÄ INIT SEQUENCE v2.3.0 (Equipment & Inventory System)");

            setTimeout(() => {
                const btn = document.getElementById('force-start-btn');
                if(btn) btn.style.display = 'block';
            }, 5000);

            try {
                bindUI();
            } catch (e) {
                window.showError("UI Error", "Failed to bind UI. " + e.message);
                return;
            }

            try {
                logBoot("Step 1: Checking Game Data...");
                // Game data is loaded via script tag (no module import needed)
                if (typeof CONTENT_PACK_ASHLORDS === 'undefined') {
                    throw new Error("Game data not loaded. Make sure game_data.js is present.");
                }
                logBoot("‚úÖ Data Loaded.");

            } catch (e) {
                logBoot(`‚ùå DATA ERROR: ${e.message}`);
                window.showError("Initialization Error", `Failed to load game data. ${e.message}`);
                return;
            }

            try {
                logBoot("Step 2: Setting up state listeners...");
                setupStateListeners();
                logBoot("‚úÖ State listeners ready.");
                hideLoading();
            } catch (e) {
                logBoot(`‚ùå SETUP ERROR: ${e.message}`);
                window.showError("Setup Error", e.message);
            }
        }

        function bindUI() {
            const safeBind = (id) => document.getElementById(id);

            ui.loading = safeBind('loading-overlay');
            ui.charCreation = safeBind('character-creation-ui');
            ui.mainGame = safeBind('main-game-ui');
            ui.callingOpts = safeBind('calling-options');
            ui.burdenOpts = safeBind('burden-options');
            ui.burdenDetailWrap = safeBind('burden-detail-input-wrapper');
            ui.burdenDetailInput = safeBind('burden-detail-input');
            ui.burdenDetailLabel = safeBind('burden-detail-label');
            ui.charName = safeBind('character-name');
            ui.playerInput = safeBind('player-input');
            ui.modal = safeBind('error-modal');
            ui.characterSheetLoading = safeBind('character-sheet-loading');
            ui.worldClocksContainer = safeBind('world-clocks-container');
            ui.chapterUI = safeBind('chapter-phase-ui');
            ui.interludeUI = safeBind('interlude-phase-ui');
            
            const btnCreate = safeBind('create-character-btn');
            if (btnCreate) btnCreate.addEventListener('click', createCharacterAndStartGame);
            
            const btnSubmit = safeBind('submit-action-btn');
            if (btnSubmit) btnSubmit.addEventListener('click', handlePlayerAction);
            
            const btnReset = safeBind('reset-game-btn');
            if (btnReset) btnReset.addEventListener('click', resetGame);
            
            const btnTrain = safeBind('interlude-train-btn');
            if (btnTrain) btnTrain.addEventListener('click', () => handleInterludeAction('seek_training'));
            
            const btnAsset = safeBind('interlude-asset-btn');
            if (btnAsset) btnAsset.addEventListener('click', () => handleInterludeAction('acquire_asset'));
            
            const btnReflect = safeBind('interlude-reflect-btn');
            if (btnReflect) btnReflect.addEventListener('click', () => handleInterludeAction('reflect'));

            const btnHeal = safeBind('interlude-heal-btn');
            if (btnHeal) btnHeal.addEventListener('click', () => handleInterludeAction('heal'));

            const btnShop = safeBind('interlude-shop-btn');
            if (btnShop) btnShop.addEventListener('click', () => openXPShop());

            const btnRepair = safeBind('interlude-repair-btn');
            if (btnRepair) btnRepair.addEventListener('click', () => handleInterludeAction('repair_armor'));

            const btnShopClose = safeBind('xp-shop-close-btn');
            if (btnShopClose) btnShopClose.addEventListener('click', () => {
                const modal = document.getElementById('xp-shop-modal');
                if (modal) modal.style.display = 'none';
            });

            const btnEnd = safeBind('interlude-end-btn');
            if (btnEnd) btnEnd.addEventListener('click', () => handleInterludeAction('end_interlude'));

            if(ui.playerInput) ui.playerInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handlePlayerAction(); } });
            
            const btnCloseModal = safeBind('close-modal-btn');
            if(btnCloseModal && ui.modal) {
                 btnCloseModal.addEventListener('click', () => {
                    ui.modal.style.display = 'none';
                 });
            }

            const toggleAccordion = (headerId, contentId, iconId) => {
                const header = document.getElementById(headerId);
                const content = document.getElementById(contentId);
                const icon = document.getElementById(iconId);
                if(header && content) {
                    header.onclick = () => {
                        const isHidden = content.style.display === 'none';
                        content.style.display = isHidden ? 'block' : 'none';
                        if(icon) icon.style.transform = isHidden ? 'rotate(0deg)' : 'rotate(-90deg)';
                    };
                }
            };
            toggleAccordion('character-sheet-header', 'character-sheet-content', 'accordion-icon');
            toggleAccordion('unified-clocks-header', 'unified-clocks-content', 'unified-accordion-icon');

            window.forceUI = () => {
                if(ui.loading) ui.loading.style.display = 'none';
                if(ui.charCreation) ui.charCreation.style.display = 'block';
                renderOptions();
            };
        }

        function setupStateListeners() {
            // Character updates
            gameState.subscribe('character', (character) => {
                logBoot("üì° Character Update");
                if (character) {
                    ui.charCreation.style.display = 'none';
                    ui.mainGame.style.display = 'block';
                    displayCharacter(character);
                } else {
                    ui.mainGame.style.display = 'none';
                    ui.charCreation.style.display = 'block';
                    renderOptions();
                }
            });

            // Chat history updates
            gameState.subscribe('chatHistory', (chatHistory) => {
                displayChatHistory(chatHistory || []);
            });

            // World clocks
            gameState.subscribe('worldClocks', (worldClocks) => {
                if (worldClocks) displayWorldClocks(worldClocks);
            });

            // Destiny and Front clocks
            gameState.subscribe('destinyFrontClocks', (clocks) => {
                if (clocks) {
                    displayDestinyClock(clocks.destiny);
                    displayEndgameFront(clocks.front);
                }
            });

            // Quest state
            gameState.subscribe('questState', (questState) => {
                if (questState?.current_quest) {
                    displayQuestProgress(questState.current_quest);
                } else {
                    hideQuestProgress();
                }
            });

            // Game state (phase changes)
            gameState.subscribe('gameState', (state) => {
                if (state) {
                    if (state.phase === 'interlude' || state.phase === 'downtime') {
                        ui.chapterUI.style.display = 'none';
                        ui.interludeUI.style.display = 'block';
                    } else {
                        ui.chapterUI.style.display = 'block';
                        ui.interludeUI.style.display = 'none';
                    }
                }
            });

            // Tags - refresh character sheet when tags change
            gameState.subscribe('tags', (tags) => {
                const character = gameState.getState().character;
                if (character) {
                    displayCharacter(character);
                }
            });
        }

        // Function to manually trigger downtime (can be called by player or code)
        async function triggerDowntime() {
            await gameState.transaction(async (state) => ({
                gameState: {
                    ...state.gameState,
                    phase: 'downtime'
                }
            }));
            showToast('Entering Downtime Phase...');
            await addMessageToChat('model', `**Downtime begins.**\n\nThe immediate danger has passed, and you find a moment to catch your breath. The world continues to turn‚Äîfactions plot, threats loom‚Äîbut for now, you have time to rest, reflect, or prepare.\n\nChoose your downtime actions wisely. When you return to adventure, the faction clocks will advance.`);
        }

        function renderOptions() {
            const createStatLine = (stats) => {
                const positive = Object.entries(stats).filter(([, v]) => v > 0);
                const negative = Object.entries(stats).filter(([, v]) => v < 0);
                
                const format = ([k, v]) => {
                    const sign = v > 0 ? '+' : '';
                    const colorClass = v > 0 ? 'text-emerald-400' : 'text-gray-500';
                    return `<span class="${colorClass}">${k.toUpperCase()} ${sign}${v}</span>`;
                };
                
                const posStr = positive.map(format).join(' / ');
                const negStr = negative.map(format).join(' / ');
                
                if (posStr && negStr) return `${posStr} / ${negStr}`;
                return posStr || negStr;
            };
                
            if (ui.callingOpts) {
                ui.callingOpts.innerHTML = '';
                CONTENT_PACK_ASHLORDS.callings.forEach(c => {
                    const tHtml = (c.talents||[]).map(t=>`<div><b class="text-gray-300">${t.name}</b>: <span class="text-gray-400 text-xs">${t.description}</span></div>`).join('');
                    const card = document.createElement('div');
                    card.className = 'playbook-card p-4 rounded-lg cursor-pointer border border-gray-700 mb-2';
                    card.dataset.id = c.id;
                    card.innerHTML = `<h4 class="text-white font-bold">${c.name}</h4><p class="text-gray-400 text-sm mb-2">${c.description}</p><div class="text-xs font-mono mb-2">${createStatLine(c.stats)}</div><div class="space-y-1">${tHtml}</div>`;
                    card.onclick = () => { if(ui.callingOpts) Array.from(ui.callingOpts.children).forEach(x=>x.classList.remove('selected')); card.classList.add('selected'); };
                    ui.callingOpts.appendChild(card);
                });
            }

            if (ui.burdenOpts) {
                ui.burdenOpts.innerHTML = '';
                CONTENT_PACK_ASHLORDS.burdens.forEach(b => {
                    const tHtml = (b.talents||[]).map(t=>`<div><b class="text-gray-300">${t.name}</b>: <span class="text-gray-400 text-xs">${t.description}</span></div>`).join('');
                    const card = document.createElement('div');
                    card.className = 'playbook-card p-4 rounded-lg cursor-pointer border border-gray-700 mb-2';
                    card.dataset.id = b.id;
                    card.dataset.requiresInput = b.requiresInput;
                    card.innerHTML = `<h4 class="text-white font-bold">${b.name}</h4><p class="text-gray-400 text-sm mb-2">${b.description}</p><div class="text-xs font-mono mb-2">${createStatLine(b.stats)}</div><div class="space-y-1">${tHtml}</div>`;
                    card.onclick = () => {
                        if(ui.burdenOpts) Array.from(ui.burdenOpts.children).forEach(x=>x.classList.remove('selected')); card.classList.add('selected');
                        if(ui.burdenDetailWrap) ui.burdenDetailWrap.style.display = b.requiresInput ? 'block' : 'none';
                        if(b.requiresInput && ui.burdenDetailLabel) ui.burdenDetailLabel.textContent = b.inputLabel || "Define details:";
                    };
                    ui.burdenOpts.appendChild(card);
                });
            }
        }

        function displayCharacter(data) {
            const sheet = document.getElementById('character-sheet-data');
            if (!sheet) return;
            if(ui.characterSheetLoading) ui.characterSheetLoading.style.display = 'none';
            
            if(CONTENT_PACK_ASHLORDS && data.playbook) {
                const callingName = data.playbook?.calling;
                const callingObj = callingName ? CONTENT_PACK_ASHLORDS.callings.find(c => c.name === callingName) : null;
                
                if(callingObj) {
                    const questData = CONTENT_PACK_ASHLORDS.LEGENDARY_QUESTS ? CONTENT_PACK_ASHLORDS.LEGENDARY_QUESTS[callingObj.id] : null;
                    const destinyText = document.getElementById('destiny-narrative');
                    if(questData && destinyText) {
                        destinyText.textContent = questData.title; 
                        destinyText.style.color = "var(--c-alchemical-gold)";
                    }
                }
            }

            const pipsData = data.pips || {}; 
            
            const statsHtml = Object.entries(data.stats || {}).map(([k,v]) => {
                const pipCount = pipsData[k] || 0;
                const pip1Class = pipCount >= 1 ? "filled" : "";
                const pip2Class = pipCount >= 2 ? "filled" : "";
                
                return `
                <div class="stat-block p-2 text-center border border-gray-700 rounded hover:bg-gray-700" onclick="updateDescription('${k}', 'Pips: ${pipCount}/2', 'stat')">
                    <div class="text-xs text-gray-400 uppercase">${k.substring(0,3)}</div>
                    <div class="text-xl font-bold ${v>0?'text-emerald-400':'text-gray-300'}">${v>0?'+'+v:v}</div>
                    <div class="pip-container">
                        <div class="pip ${pip1Class}"></div>
                        <div class="pip ${pip2Class}"></div>
                    </div>
                </div>`;
            }).join('');
            
            const escapeStr = (str) => str.replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, ' ');

            const talentsHtml = (data.talents||[]).map(t=> {
                return `<div class="talent-block p-2 border border-gray-700 rounded text-center hover:border-emerald-500" onclick="updateDescription('${escapeStr(t.name)}', '${escapeStr(t.description)}', 'talent')"><span class="text-sm text-gray-300">${t.name}</span></div>`
            }).join('');
            
            const equipHtml = (data.equipment || []).map(i => {
                const safeName = (i.name || 'Unknown Item').replace(/'/g, "&apos;");
                const loreContent = (i.lore || i.desc || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, '\\n');

                // Build special display for tools and armor
                let specialBadge = '';
                if (i.type === 'tool' && i.stat) {
                    // Tool: show "+1 STAT" badge
                    specialBadge = `<span class="equip-tag text-emerald-400 border border-emerald-600 bg-emerald-900/30">+1 ${i.stat.substring(0,3)}</span>`;
                } else if (i.type === 'armor' && i.stat) {
                    // Armor: show pip meter
                    const currentPips = i.pips || 0;
                    const maxPips = i.max_pips || 2;
                    const pipDisplay = '‚óè'.repeat(currentPips) + '‚óã'.repeat(maxPips - currentPips);
                    const pipColor = currentPips === maxPips ? 'text-blue-400' :
                                    currentPips === 0 ? 'text-red-400' : 'text-yellow-400';
                    specialBadge = `<span class="equip-tag ${pipColor} border border-gray-600">${pipDisplay}</span>`;
                } else {
                    // Regular items: show property badges
                    const safeProperties = (i.properties || []).filter(p => p);
                    specialBadge = safeProperties.map(p => {
                        if (typeof p !== 'string') return '';
                        const type = p.toLowerCase().includes('heavy') ? 'heavy' :
                                     p.toLowerCase().includes('silver') || p.toLowerCase().includes('gold') || p.toLowerCase().includes('precious') ? 'precious' :
                                     p.toLowerCase().includes('consumable') ? 'consumable' :
                                     p.toLowerCase().includes('fragile') || p.toLowerCase().includes('shabby') ? 'fragile' : '';
                        return `<span class="equip-tag ${type}">${p}</span>`;
                    }).join(' ');
                }

                // Type badge
                const typeBadge = i.type && i.type !== 'loot'
                    ? `<span class="text-xs px-1 rounded ${i.type === 'tool' ? 'bg-emerald-900 text-emerald-300' : i.type === 'armor' ? 'bg-blue-900 text-blue-300' : 'bg-gray-700 text-gray-400'}">${i.type}</span>`
                    : '';

                return `<li class="text-sm text-gray-300 py-2 border-b border-gray-800 cursor-pointer hover:text-emerald-400 flex justify-between items-center" onclick="updateDescription('${safeName}', '', 'item', '${loreContent}')">
                    <span class="flex items-center gap-2">${typeBadge}${i.name}</span>
                    <div class="text-right">${specialBadge}</div>
                </li>`;
            }).join('');

            // Build Tags HTML
            const currentState = gameState.getState();
            const tags = currentState.tags || [];
            const tagsHtml = tags.length > 0
                ? tags.map(t => {
                    const typeColors = {
                        'story': 'bg-gray-600',
                        'reputation': 'bg-amber-800',
                        'relationship': 'bg-blue-800',
                        'secret': 'bg-purple-800'
                    };
                    const colorClass = typeColors[t.type] || 'bg-gray-600';
                    const safeDesc = (t.description || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                    return `<span class="inline-block px-2 py-1 ${colorClass} text-xs text-white rounded cursor-pointer hover:opacity-80 mr-1 mb-1" onclick="updateDescription('${escapeStr(t.name)}', '${safeDesc}', 'tag')">${t.name}</span>`;
                }).join('')
                : '<span class="text-gray-500 text-xs italic">No tags yet. Earn them through play.</span>';
            
            // UI UPDATE (v0.9.5): Removed the Conditions container div
            sheet.innerHTML = `
                <div class="space-y-4">
                    <div class="flex justify-between items-end">
                        <div>
                            <h3 class="text-xl font-bold text-white">${data.name || "Unknown"}</h3>
                            <p class="text-sm text-emerald-400">${data.playbook?.calling || "?"} / ${data.playbook?.burden || "?"}</p>
                        </div>
                        <div class="text-right flex items-center space-x-4">
                             <div>
                                 <p class="text-xs text-gray-500">EXP</p>
                                 <p class="text-lg font-bold text-emerald-400">${data.xp || 0}</p>
                             </div>
                             <div>
                                 <p class="text-xs text-gray-500">COIN</p>
                                 <p class="text-lg font-bold text-emerald-400">${data.currency || 0}</p>
                             </div>
                        </div>
                    </div>
                    <div class="grid grid-cols-5 gap-2 select-none">${statsHtml}</div>
                    <div>
                        <h4 class="text-xs uppercase font-semibold text-gray-500 mb-2 tracking-wider">Talents</h4>
                        <div class="grid grid-cols-2 gap-2">${talentsHtml || '<p class="text-sm text-gray-500 italic col-span-2">No talents.</p>'}</div>
                    </div>
                    <div>
                        <h4 class="text-xs uppercase font-semibold text-gray-500 mb-2 tracking-wider">Equipment</h4>
                        <ul class="space-y-0">${equipHtml || '<span class="text-gray-500 text-xs">None</span>'}</ul>
                    </div>
                    <div>
                        <h4 class="text-xs uppercase font-semibold text-gray-500 mb-2 tracking-wider">Tags</h4>
                        <div class="flex flex-wrap">${tagsHtml}</div>
                    </div>
                    <div id="description-display" class="text-sm text-left text-gray-400 min-h-[3.5em] p-3 bg-gray-900 rounded-r-lg flex flex-col justify-center mt-2 border-t-2 border-gray-800">
                        <span class="italic opacity-50">Select any attribute, talent, item, or tag above to view details.</span>
                    </div>
                </div>`;
        }

        window.updateDescription = (title, description, type, lore = '') => {
            const display = document.getElementById('description-display');
            if(display) {
                let content = `<strong class="text-emerald-400 block mb-1">${title}</strong>`;
                if(description) content += `<p class="text-gray-400 text-sm mb-2">${description}</p>`;
                if (lore) content += `<div class="mt-2 pt-2 border-t border-gray-700 font-mono text-xs text-red-300">${lore.replace(/\\n/g, '<br>')}</div>`;
                
                display.innerHTML = content;
                display.classList.remove('active');
                void display.offsetWidth; 
                display.classList.add('active');
            }
        };

        async function createCharacterAndStartGame() {
            const charName = ui.charName.value.trim();
            const selectedCallingEl = ui.callingOpts.querySelector('.selected');
            const selectedBurdenEl = ui.burdenOpts.querySelector('.selected');

            if (!charName || !selectedCallingEl || !selectedBurdenEl) {
                return window.showError("Missing Info", "Please fill all fields.");
            }

            showLoading();

            try {
                const callingId = selectedCallingEl.dataset.id;
                const burdenId = selectedBurdenEl.dataset.id;
                const calling = CONTENT_PACK_ASHLORDS.callings.find(c => c.id === callingId);
                const burden = CONTENT_PACK_ASHLORDS.burdens.find(b => b.id === burdenId);

                const combinedStats = { FORCE: 0, FINESSE: 0, INFLUENCE: 0, WITS: 0, RESOLVE: 0 };
                for (const stat in combinedStats) {
                    combinedStats[stat] = (calling.stats[stat] || 0) + (burden.stats[stat] || 0);
                }

                const newCharacter = {
                    name: charName,
                    playbook: { calling: calling.name, burden: burden.name },
                    stats: combinedStats,
                    pips: {},
                    talents: [...(calling.talents || []), ...(burden.talents || [])],
                    equipment: [...(calling.equipment || []), ...(burden.equipment || [])],
                    xp: 0,
                    xp_locked: 0,
                    currency: 0
                };

                // Get front name from calling
                const fronts = CONTENT_PACK_ASHLORDS.endgame_fronts || {};
                const frontInfo = fronts[callingId];

                // Initialize world clocks
                const clockData = (CONTENT_PACK_ASHLORDS.FACTIONS || []).map(f => ({
                    name: f.name,
                    current: 0,
                    segments: 6,
                    goal: f.goal || "Advance Agenda"
                }));

                // Update state atomically
                await gameState.transaction(async (state) => ({
                    character: newCharacter,
                    gameState: {
                        phase: 'adventure',
                        turn_count: 0,
                        saga_log: "The story begins...",
                        current_location: "The Tavern"
                    },
                    worldClocks: {
                        clocks: clockData
                    },
                    destinyFrontClocks: {
                        destiny: { current: 0, segments: 8 },
                        front: {
                            current: 0,
                            segments: 8,
                            name: frontInfo?.name || "The Threat Looms"
                        }
                    },
                    campaign: {
                        id: "ashlords_covenant_main_v1",
                        started_at: Date.now(),
                        active: true,
                        version: "1.0.0"
                    },
                    chatHistory: [{
                        role: 'model',
                        content: "You are in a dimly lit tavern, the air thick with stale ale and desperation. Ash-Warden enforcers, clad in rusted, reinforced plate armor, are shaking down the tavern keeper over a fabricated 'Blight Tax'. One guard, his face a mask of bored cruelty beneath a grim iron visor, shoves the old man. 'Pay up, or we shut you down.' What do you do?",
                        timestamp: Date.now(),
                        id: crypto.randomUUID()
                    }]
                }));

            } catch (error) {
                window.showError("Creation Failed", error.message);
            } finally {
                hideLoading();
            }
        }

        async function handlePlayerAction() {
            const text = ui.playerInput.value.trim();
            if (!text) return;

            ui.playerInput.value = '';
            ui.playerInput.disabled = true;
            document.getElementById('submit-action-btn').disabled = true;
            showLoading();

            try {
                // Add user message
                await addMessageToChat('user', text);

                const state = gameState.getState();
                const character = state.character;

                // 1. Parse player intent (client-side)
                const intent = MechanicsEngine.parseIntent(text);
                console.log("Parsed intent:", intent);

                let rollResult = null;
                let consequences = null;
                let mechanicsContext = null;

                // 2. If action needs a roll, handle mechanics client-side
                if (intent.needsRoll && intent.stat) {
                    // Roll dice
                    rollResult = MechanicsEngine.rollDice(intent.stat, intent.tier, character);
                    console.log("Roll result:", rollResult);

                    // Calculate consequences (with Escalation Oracle for costs)
                    consequences = MechanicsEngine.getConsequences(rollResult, intent.type);
                    console.log("Consequences:", consequences);

                    // Apply consequences to game state
                    await MechanicsEngine.applyConsequences(consequences);

                    // If Escalation Oracle says advance threat, do it
                    if (consequences.escalation?.advanceThreat) {
                        await gameState.transaction(async (state) => {
                            const front = state.destinyFrontClocks?.front || {};
                            return {
                                destinyFrontClocks: {
                                    ...state.destinyFrontClocks,
                                    front: {
                                        ...front,
                                        current: Math.min(front.segments || 8, (front.current || 0) + 1)
                                    }
                                }
                            };
                        });
                        showToast('The Threat advances...');
                    }

                    // Build mechanics context for AI
                    mechanicsContext = MechanicsEngine.formatRollResult(rollResult);
                    mechanicsContext += `\nOutcome: ${consequences.description}`;
                    if (consequences.add_pips) {
                        mechanicsContext += `\nPlayer takes ${consequences.add_pips.amount} pip(s) of ${consequences.add_pips.stat} damage.`;
                    }
                    if (consequences.escalation) {
                        mechanicsContext += `\nEscalation Oracle (d6=${consequences.escalation.d6}): ${consequences.escalation.description}`;
                    }
                    // Add Oracle-generated twist for AI to narrate
                    if (consequences.twist) {
                        mechanicsContext += `\n\n*** COMPLICATION TO NARRATE ***\n"${consequences.twist.description}"`;
                        if (consequences.twist.type === 'major') {
                            mechanicsContext += `\n(This is a MAJOR complication - make it dramatic and consequential!)`;
                        }
                    }
                }

                // 3. Call AI for narrative only (much simpler prompt)
                const narrative = await callAINarrative(text, mechanicsContext);

                // 4. Build and display the full message
                let fullMessage = narrative;
                if (rollResult) {
                    // Append mechanics in styled block
                    const mechanicsDisplay = MechanicsEngine.formatRollResult(rollResult);
                    fullMessage += `\n\n<mechanics>${mechanicsDisplay}</mechanics>`;
                }

                await addMessageToChat('model', fullMessage);

                // 5. Increment turn counts
                await gameState.transaction(async (state) => ({
                    gameState: {
                        ...state.gameState,
                        turn_count: (state.gameState?.turn_count || 0) + 1,
                        adventure_turn_count: (state.gameState?.adventure_turn_count || 0) + 1
                    }
                }));

                // 6. Check for automatic downtime trigger
                const newState = gameState.getState();
                if (WorldTurn.shouldTriggerDowntime(newState)) {
                    console.log("Downtime trigger conditions met!");
                    // Don't auto-transition yet, let the next AI response suggest it
                    // The AI will be aware of the adventure_turn_count and suggest downtime
                }

            } catch (e) {
                console.error("Action Error:", e);
                window.showError("GM Response Error", e.message);
            } finally {
                ui.playerInput.disabled = false;
                ui.playerInput.focus();
                document.getElementById('submit-action-btn').disabled = false;
                hideLoading();
            }
        }

        // ===== NARRATIVE AI (Simplified - mechanics handled client-side) =====
        async function callAINarrative(playerAction, mechanicsContext) {
            const PROXY_URL = 'https://ash-lords-rpg-proxy.jweisgrau.workers.dev';

            const state = gameState.getState();
            const character = state.character;
            const chatHistory = state.chatHistory || [];
            const recentMessages = chatHistory.slice(-10);

            // Build conversation context
            const conversationContext = recentMessages
                .map(m => `${m.role.toUpperCase()}: ${m.content}`)
                .join('\n\n');

            // Build character context
            const pipsData = character.pips || {};
            let pipContext = Object.entries(pipsData)
                .filter(([_, count]) => count > 0)
                .map(([stat, count]) => `${stat}: ${count} Pips`)
                .join(', ') || "None";

            // Get tags context
            const tagsContext = TagSystem.getTagsContext(state);

            // Check quest availability and roll quest hook if needed
            const turnCount = state.gameState?.turn_count || 0;
            const hasQuest = state.questState?.current_quest != null;
            const shouldOfferQuest = turnCount >= 3 && !hasQuest;
            const questHook = shouldOfferQuest ? OracleSystem.rollQuestHook() : null;

            // Check downtime suggestion
            const adventureTurns = state.gameState?.adventure_turn_count || 0;
            const shouldSuggestDowntime = adventureTurns >= 5;

            // Get faction clock status for context
            const factionStatus = (state.worldClocks?.clocks || [])
                .map(c => `${c.name}: ${c.current}/${c.segments}`)
                .join(', ') || "Unknown";

            const systemPrompt = `You are the AI GM for "The Ash-Lord's Covenant", a grimdark political fantasy RPG.

*** YOUR ROLE ***
Write ONLY narrative/story text. All game mechanics (dice rolls, damage, XP) are handled by the game code.
You receive the mechanical outcome and must narrate what happens based on it.

*** CHARACTER ***
Name: ${character.name}
Calling: ${character.playbook?.calling} / Burden: ${character.playbook?.burden}
Stats: FOR ${character.stats.FORCE}, FIN ${character.stats.FINESSE}, INF ${character.stats.INFLUENCE}, WIT ${character.stats.WITS}, RES ${character.stats.RESOLVE}
Injuries: ${pipContext}
Equipment: ${(character.equipment||[]).map(e => {
    if (e.type === 'tool') return `${e.name} (+1 ${e.stat})`;
    if (e.type === 'armor') return `${e.name} (${e.pips || 0}/${e.max_pips || 2} ${e.stat} armor)`;
    return e.name;
}).join(', ')}
Coin: ${character.currency}
XP: ${character.xp || 0}

*** CHARACTER TAGS (Story facts about the character) ***
${tagsContext}

*** GAME STATE ***
Turn: ${turnCount} | Adventure Turns Since Rest: ${adventureTurns}
Location: ${state.gameState?.current_location || "Unknown"}
Active Quest: ${hasQuest ? state.questState.current_quest.title : "None"}

*** FACTION CLOCK STATUS ***
${factionStatus}

*** RECENT STORY ***
${conversationContext}

*** WORLD FACTIONS (Use ONLY these) ***
- The Ash-Wardens: Corrupt enforcers of a tyrannical regime
- The Soot-Stained: Criminal underground, desperate survivors
- The Iron-Forgers: Ruthless industrialists exploiting workers
- Whispering Flesh: Flesh-warping cultists with dark secrets

*** PACING GUIDANCE ***
${questHook ? `
QUEST HOOK (use this exact structure):
- Present to player: "${questHook.epic_hook}"
- Hidden truth (reveal later as they investigate): "${questHook.political_truth}"
- Faction involved: ${questHook.faction}
- Tier: ${questHook.tier}
Work this quest opportunity naturally into your narrative through an NPC, rumor, or environmental discovery.
` : ''}
${shouldSuggestDowntime ? `DOWNTIME HINT: The player has been active for ${adventureTurns} turns. If appropriate, suggest a natural pause point (finding shelter, reaching a destination, completing an objective) where they could rest.` : ''}

*** WRITING STYLE ***
- Grimdark, morally ambiguous, consequences matter
- 2-4 paragraphs of vivid prose
- Show don't tell
- End with a hook or new situation
- If mechanics are provided, weave them naturally into the narrative
- Reference the character's Tags when relevant to create callbacks
- NEVER mention game mechanics explicitly (no "XP", "pips", "dice")
- Describe injuries as wounds, exhaustion, strain - not as "pips"

*** STEALING GUIDANCE ***
When the player successfully steals (action type 'steal'), you MUST determine what was stolen based on context:
- Pickpocketing commoners: coin purse (1-3 coin), trinkets, bread
- Pickpocketing merchants: coin pouch (2-6 coin), keys, receipts, small tools
- Pickpocketing nobles: valuable jewelry (5-10 coin value), sealed letters, signet rings
- Looting bodies: weapons, armor pieces, coin, evidence, personal effects
- Burglary/theft from locations: tools, documents, valuables, supplies

For SUCCESS: Award full loot. Include "currency_gain: X" in your structured response (X = 1-6 depending on target).
For COST/PARTIAL: Award reduced loot. Include "currency_gain: X" (X = 1-3) or a lesser item.
For MISS: No loot is obtained. Narrate the failure and consequences.

You can also add interesting narrative items with: equipment_add: [{name: "Item Name", type: "loot", tags: ["tag1"], desc: "Description"}]

*** COMPLICATION GUIDANCE ***
If a "COMPLICATION TO NARRATE" is provided in the mechanical result:
- Weave it NATURALLY into your narrative - it's pre-written "witty grimdark" text
- Honor the tone and specifics of the complication
- Do NOT invent additional complications - the oracle has spoken
- For MAJOR complications, make them dramatic and consequential
- The complication may reference factions, environmental changes, or character setbacks`;

            // Build the user prompt with mechanics context
            let userPrompt = `PLAYER ACTION: "${playerAction}"`;

            if (mechanicsContext) {
                userPrompt += `\n\n*** MECHANICAL RESULT (narrate this outcome) ***\n${mechanicsContext}`;
            }

            const payload = {
                contents: [
                    { role: 'user', parts: [{ text: systemPrompt }] },
                    ...recentMessages.map(m => ({
                        role: m.role === 'model' ? 'model' : 'user',
                        parts: [{ text: m.content }]
                    })),
                    { role: 'user', parts: [{ text: userPrompt }] }
                ],
                generationConfig: {
                    temperature: 0.9,
                    topP: 0.95,
                    maxOutputTokens: 8192
                }
            };

            // API call with retry
            let attempts = 0;
            const maxAttempts = 3;

            while (attempts < maxAttempts) {
                try {
                    const response = await fetch(PROXY_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: "gemini-3-flash-preview",
                            payload: payload
                        })
                    });

                    if (response.status === 429 || response.status === 503) {
                        attempts++;
                        await new Promise(r => setTimeout(r, 2000 * attempts));
                        continue;
                    }

                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(`API HTTP ${response.status}: ${errText}`);
                    }

                    const data = await response.json();

                    // Log full response structure to diagnose truncation
                    console.log("Full API response:", JSON.stringify(data, null, 2));
                    const candidate = data.candidates?.[0];
                    const finishReason = candidate?.finishReason;
                    console.log("API finishReason:", finishReason);
                    console.log("Token usage:", data.usageMetadata);
                    if (finishReason && finishReason !== 'STOP') {
                        console.warn("Response may be truncated. Reason:", finishReason);
                    }

                    const text = candidate?.content?.parts?.[0]?.text;

                    if (!text) {
                        console.error("API response:", data);
                        throw new Error("No text in response");
                    }

                    return text;

                } catch (e) {
                    if (attempts === maxAttempts - 1) throw e;
                    attempts++;
                    await new Promise(r => setTimeout(r, 2000 * attempts));
                }
            }
        }
        
        async function processStateUpdate(update) {
            if (!update) return;

            await gameState.transaction(async (state) => {
                const character = state.character;
                const updates = {};

                // XP gain
                if (update.xp_gain) {
                    updates.character = {
                        ...character,
                        xp: (character.xp || 0) + update.xp_gain
                    };
                    showToast(`+${update.xp_gain} XP`);
                }

                // Currency gain/loss
                if (update.currency_gain !== undefined && update.currency_gain !== 0 && update.currency_gain !== null) {
                    const amount = Number(update.currency_gain);
                    if (!isNaN(amount) && amount !== 0) {
                        const newCurrency = Math.max(0, (character.currency || 0) + amount);
                        updates.character = {
                            ...(updates.character || character),
                            currency: newCurrency
                        };
                        showToast(`${amount > 0 ? '+' : ''}${amount} Coin`);
                        console.log(`Currency update: ${character.currency} + ${amount} = ${newCurrency}`);
                    }
                }

                // Pips
                let currentPips = { ...(character.pips || {}) };
                let pipChanged = false;

                if (update.add_pips) {
                    const stat = update.add_pips.stat;
                    const amt = update.add_pips.amount || 1;
                    currentPips[stat] = Math.min(2, (currentPips[stat] || 0) + amt);
                    pipChanged = true;
                    showToast(`${stat} damage: +${amt} pip${amt > 1 ? 's' : ''}`);
                }

                if (update.remove_pips && update.remove_pips.stat && update.remove_pips.amount > 0) {
                    const stat = update.remove_pips.stat;
                    const amt = update.remove_pips.amount;
                    const currentPipValue = currentPips[stat] || 0;
                    if (currentPipValue > 0) {
                        currentPips[stat] = Math.max(0, currentPipValue - amt);
                        pipChanged = true;
                        showToast(`${stat} healed: -${amt} pip${amt > 1 ? 's' : ''}`);
                    }
                }

                if (pipChanged) {
                    updates.character = {
                        ...(updates.character || character),
                        pips: currentPips
                    };
                }

                // Equipment add
                if (update.equipment_add && update.equipment_add.length > 0) {
                    const currentEquipment = character.equipment || [];
                    const newItems = update.equipment_add.map(item => ({
                        name: item.name || "Unknown Item",
                        properties: item.properties || [],
                        lore: item.lore || ""
                    }));

                    updates.character = {
                        ...(updates.character || character),
                        equipment: [...currentEquipment, ...newItems]
                    };

                    newItems.forEach(item => showToast(`+1 Item: ${item.name}`));
                }

                // Equipment modify
                if (update.item_modify && update.item_modify.length > 0) {
                    const currentEquipment = character.equipment || [];
                    const modifiedEquipment = currentEquipment.map(item => {
                        const modification = update.item_modify.find(mod => mod.name === item.name);
                        if (modification) {
                            showToast(`Item modified: ${modification.name}`);
                            return {
                                ...item,
                                name: modification.new_name || item.name,
                                lore: modification.lore || item.lore
                            };
                        }
                        return item;
                    });

                    updates.character = {
                        ...(updates.character || character),
                        equipment: modifiedEquipment
                    };
                }

                // Clock advancement
                if (update.clocks_advance && update.clocks_advance.length > 0) {
                    const worldClocks = { ...state.worldClocks };
                    const clocks = [...(worldClocks.clocks || [])];

                    update.clocks_advance.forEach(adv => {
                        const clock = clocks.find(c => c.name === adv.name);
                        if (clock) {
                            clock.current = Math.min(clock.segments, (clock.current || 0) + (adv.amount || 1));
                            showToast(`${clock.name} advanced!`);
                        }
                    });

                    updates.worldClocks = { clocks };
                }

                // Quest start
                if (update.quest_start && update.quest_start.title) {
                    updates.questState = {
                        current_quest: {
                            title: update.quest_start.title,
                            chapter: update.quest_start.chapter || 1,
                            objective: update.quest_start.objective || "",
                            progress: 0,
                            max_progress: update.quest_start.max_progress || 3,
                            xp_earned: 0
                        }
                    };
                    showToast(`Quest Started: ${update.quest_start.title}`);
                }

                // Quest progress
                if (update.quest_progress && state.questState?.current_quest) {
                    const quest = { ...state.questState.current_quest };
                    quest.progress = Math.min(quest.max_progress, (quest.progress || 0) + update.quest_progress);
                    quest.xp_earned = (quest.xp_earned || 0) + 1;
                    updates.questState = { current_quest: quest };
                    showToast(`Quest progress: ${quest.progress}/${quest.max_progress}`);
                }

                // Trigger interlude
                if (update.trigger_interlude === true) {
                    updates.gameState = {
                        ...state.gameState,
                        phase: 'interlude'
                    };
                    showToast('Interlude begins - time to rest');
                }

                return updates;
            });
        }
        
        async function resetGame() {
            if (!confirm("WARNING: This will wipe your character, story, and world state. This cannot be undone.\n\nAre you sure?")) {
                return;
            }

            showLoading("Resetting game...");

            try {
                gameState.reset();
                location.reload();
            } catch (e) {
                console.error(e);
                alert("Reset Error: " + e.message);
                location.reload();
            }
        }

        // ===== XP SHOP SYSTEM =====

        function openXPShop() {
            const state = gameState.getState();
            const character = state.character;

            if ((character.xp || 0) < 5) {
                return window.showError("Insufficient XP", "You need 5 XP to browse the equipment shop.");
            }

            const items = InventorySystem.getAvailableShopItems(3);
            const container = document.getElementById('xp-shop-items');

            if (items.length === 0) {
                container.innerHTML = '<p class="text-gray-400 text-center py-4">You already own all available equipment!</p>';
            } else {
                container.innerHTML = items.map((item, idx) => {
                    const typeColor = item.type === 'tool' ? 'text-emerald-400' : 'text-blue-400';
                    const statBadge = item.stat ? `<span class="${typeColor}">${item.stat}</span>` : '';
                    const bonusText = item.type === 'tool' ? `+${item.bonus || 1} bonus` : `${item.max_pips || 2} armor pips`;

                    return `
                        <div class="bg-gray-900 border border-gray-700 rounded-lg p-3 hover:border-amber-600 transition">
                            <div class="flex justify-between items-start mb-2">
                                <div>
                                    <span class="font-bold text-white">${item.name}</span>
                                    <span class="text-xs ml-2 px-1 rounded ${item.type === 'tool' ? 'bg-emerald-900 text-emerald-300' : 'bg-blue-900 text-blue-300'}">${item.type}</span>
                                </div>
                                <span class="text-amber-400 font-bold">${item.cost_xp} XP</span>
                            </div>
                            <p class="text-gray-400 text-sm mb-2">${item.desc}</p>
                            <div class="flex justify-between items-center">
                                <span class="text-xs text-gray-500">${statBadge} ${bonusText}</span>
                                <button onclick="purchaseFromShop(${idx})" class="px-3 py-1 bg-amber-700 text-white text-sm rounded hover:bg-amber-600 transition">
                                    Purchase
                                </button>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            // Store available items for purchase reference
            window._shopItems = items;

            // Show the modal
            const modal = document.getElementById('xp-shop-modal');
            if (modal) modal.style.display = 'flex';
        }

        async function purchaseFromShop(index) {
            const items = window._shopItems || [];
            const item = items[index];
            if (!item) return;

            const state = gameState.getState();
            const character = state.character;

            if ((character.xp || 0) < item.cost_xp) {
                return window.showError("Insufficient XP", `You need ${item.cost_xp} XP to purchase this item.`);
            }

            // Deduct XP
            await gameState.transaction(async (s) => ({
                character: { ...s.character, xp: s.character.xp - item.cost_xp }
            }));
            showToast(`-${item.cost_xp} XP`);

            // Add item to inventory
            await InventorySystem.addItem(item);

            // Add narrative message
            await addMessageToChat('model', `You spend ${item.cost_xp} XP at a skilled craftsman's workshop. After careful negotiation, you acquire **${item.name}** - ${item.desc.toLowerCase()}`);

            // Close the shop and refresh it (in case they want to buy more)
            const modal = document.getElementById('xp-shop-modal');
            if (modal) modal.style.display = 'none';
        }

        async function handleInterludeAction(actionType) {
            const state = gameState.getState();
            const character = state.character;

            // Different costs for different actions
            const actionConfig = {
                seek_training: { costType: 'xp', cost: 1, label: 'Seek Training' },
                acquire_asset: { costType: 'xp', cost: 1, label: 'Acquire an Asset' },
                reflect: { costType: 'xp', cost: 1, label: 'Reflect & Integrate' },
                heal: { costType: 'coin', cost: 3, label: 'Rest & Recover' },
                repair_armor: { costType: 'none', cost: 0, label: 'Repair Armor' },
                end_interlude: { costType: 'none', cost: 0, label: 'Return to Adventure' }
            };

            const config = actionConfig[actionType];
            if (!config) return;

            // Check if player can afford the action
            if (config.costType === 'xp' && (character.xp || 0) < config.cost) {
                return window.showError("Insufficient XP", `You need ${config.cost} XP for this action.`);
            }
            if (config.costType === 'coin' && (character.currency || 0) < config.cost) {
                return window.showError("Insufficient Coin", `You need ${config.cost} coin for this action.`);
            }

            // For healing, check if there's damage to heal
            if (actionType === 'heal') {
                const hasPips = Object.values(character.pips || {}).some(p => p > 0);
                if (!hasPips) {
                    return window.showError("No Damage", "You have no injuries to heal.");
                }
            }

            // For repair armor, check if there's armor to repair
            if (actionType === 'repair_armor') {
                const hasArmorToRepair = (character.equipment || []).some(
                    e => e.type === 'armor' && (e.pips || 0) < (e.max_pips || 2)
                );
                if (!hasArmorToRepair) {
                    return window.showError("No Repairs Needed", "All your armor is already at full protection.");
                }
            }

            // Confirm action
            let confirmMsg = `${config.label}`;
            if (config.cost > 0) {
                confirmMsg += ` (Cost: ${config.cost} ${config.costType.toUpperCase()})`;
            }
            if (actionType === 'end_interlude') {
                confirmMsg += "\n\nThis will advance all faction clocks by 1 segment!";
            }
            if (!confirm(confirmMsg + "\n\nProceed?")) {
                return;
            }

            showLoading();

            try {
                // Deduct cost
                if (config.costType === 'xp') {
                    await gameState.transaction(async (s) => ({
                        character: { ...s.character, xp: s.character.xp - config.cost }
                    }));
                    showToast(`-${config.cost} XP`);
                } else if (config.costType === 'coin') {
                    await gameState.transaction(async (s) => ({
                        character: { ...s.character, currency: s.character.currency - config.cost }
                    }));
                    showToast(`-${config.cost} Coin`);
                }

                // Handle specific actions
                if (actionType === 'heal') {
                    // Find the first stat with pips and heal 1
                    const pipsEntry = Object.entries(character.pips || {}).find(([_, v]) => v > 0);
                    if (pipsEntry) {
                        const [stat, currentPips] = pipsEntry;
                        await gameState.transaction(async (s) => ({
                            character: {
                                ...s.character,
                                pips: { ...s.character.pips, [stat]: currentPips - 1 }
                            }
                        }));
                        showToast(`${stat} healed: -1 pip`);
                        await addMessageToChat('model', `You rest and tend to your wounds. Your ${stat} injury begins to mend, the pain slowly fading as you recover.`);
                    }

                } else if (actionType === 'repair_armor') {
                    // Repair all armor during downtime
                    await InventorySystem.repairAllArmor();
                    await addMessageToChat('model', `You spend time carefully maintaining your equipment. Dented plates are hammered smooth, torn padding is replaced, and worn straps are reinforced. Your armor is restored to full protection.`);

                } else if (actionType === 'end_interlude') {
                    // Execute World Turn - advance all faction clocks
                    const portents = await WorldTurn.execute();
                    showToast('Faction clocks advanced!');

                    // Generate narrative about world events
                    const worldNarrative = await WorldTurn.generateWorldTurnNarrative(portents);

                    // Transition back to adventure phase
                    await gameState.transaction(async (s) => ({
                        gameState: {
                            ...s.gameState,
                            phase: 'adventure',
                            adventure_turn_count: 0  // Reset adventure turn counter
                        }
                    }));

                    // Add world turn narrative
                    if (portents.length > 0) {
                        await addMessageToChat('model', `**The World Moves On...**\n\n${worldNarrative}\n\nYou step back into the fray, knowing the world has not waited for you.`);
                    } else {
                        await addMessageToChat('model', `The factions continue their machinations while you rested. Fresh and alert, you return to face whatever comes next.`);
                    }

                } else {
                    // For training, asset, and reflect - call AI for narrative
                    const prompt = `[DOWNTIME: ${actionType.toUpperCase()}] The player is spending downtime to ${config.label.toLowerCase()}. Write 2-3 paragraphs describing what happens. Be specific about what they learn, find, or realize. If this is "reflect", suggest a potential Tag they might gain based on recent events.`;
                    const narrative = await callAINarrative(prompt, null);
                    await addMessageToChat('model', narrative);

                    // For reflect action, potentially gain a tag (based on turn count)
                    if (actionType === 'reflect' && (state.gameState?.turn_count || 0) >= 5) {
                        // Simple tag generation based on calling
                        const tagOptions = [
                            { name: 'Battle-Scarred', type: 'story', description: 'You bear the marks of conflict' },
                            { name: 'Marked by the Ash-Wardens', type: 'reputation', description: 'The enforcers know your face' },
                            { name: 'Debt Owed', type: 'relationship', description: 'Someone helped you; they expect repayment' },
                            { name: 'Whispers Follow', type: 'reputation', description: 'People talk about your deeds' }
                        ];
                        const randomTag = tagOptions[Math.floor(Math.random() * tagOptions.length)];
                        await TagSystem.addTag(randomTag);
                    }
                }

            } catch(e) {
                console.error("Interlude Error:", e);
                window.showError("Interlude Error", e.message);
            } finally {
                hideLoading();
            }
        }

        function hideLoading() { if(ui.loading) ui.loading.style.display = 'none'; }
        function showLoading() { if(ui.loading) ui.loading.style.display = 'flex'; }

        // ===== EXPORT/IMPORT SAVE FUNCTIONS =====

        window.exportSave = function() {
            const saveData = gameState.exportState();
            const blob = new Blob([saveData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ashlords-save-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('Save exported!');
        };

        window.importSave = function() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    const success = gameState.importState(event.target.result);
                    if (success) {
                        showToast('Save imported successfully!');
                        setTimeout(() => location.reload(), 1000);
                    } else {
                        window.showError('Import Failed', 'Invalid save file');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        };

        // ===== DISPLAY FUNCTIONS (Restored from archive) =====

        async function addMessageToChat(role, content) {
            await gameState.transaction(async (state) => {
                const history = [...(state.chatHistory || [])];

                history.push({
                    role,
                    content,
                    timestamp: Date.now(),
                    id: crypto.randomUUID()
                });

                // Keep only last 30 messages
                const trimmed = history.slice(-30);

                return { chatHistory: trimmed };
            });
        }

        function showToast(message, duration = 3000) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, duration);
        }

        function displayChatHistory(messages) {
            const log = document.getElementById('narrative-log');
            if (!log) return;

            log.innerHTML = '';

            messages.forEach(msg => {
                const bubble = document.createElement('div');
                bubble.className = msg.role === 'user'
                    ? 'narrative-bubble-user'
                    : 'narrative-bubble-model';

                // Parse mechanics blocks
                let content = msg.content;
                if (msg.role === 'model') {
                    content = content.replace(
                        /<mechanics>(.*?)<\/mechanics>/gi,
                        '<div class="mechanics-text">$1</div>'
                    );
                }

                bubble.innerHTML = content;
                log.appendChild(bubble);
            });

            // Scroll to bottom
            log.scrollTop = log.scrollHeight;
        }

        function displayWorldClocks(data) {
            const container = document.getElementById('world-clocks-container');
            if (!container) return;

            const loading = document.getElementById('world-clocks-loading');
            if (loading) loading.style.display = 'none';

            container.innerHTML = '';

            (data.clocks || []).forEach(clock => {
                const clockDiv = document.createElement('div');
                clockDiv.className = 'clock';
                clockDiv.innerHTML = `
                    <div class="clock-face ${clock.current >= clock.segments - 1 ? 'near-full' : ''}"
                         id="clock-${clock.name.replace(/\s+/g, '-')}">
                        ${renderClockSegments(clock.current, clock.segments)}
                    </div>
                    <div class="clock-name">${clock.name}</div>
                    <div class="text-xs text-gray-500 text-center mt-1">${clock.current}/${clock.segments}</div>
                `;
                container.appendChild(clockDiv);
            });
        }

        function renderClockSegments(current, total) {
            let html = '';
            for (let i = 0; i < total; i++) {
                const angle = (360 / total) * i;
                const filled = i < current ? 'filled' : '';
                html += `<div class="clock-segment ${filled}" style="transform: rotate(${angle}deg)"></div>`;
            }
            return html;
        }

        function displayDestinyClock(data) {
            const face = document.getElementById('destiny-clock-face');
            if (!face) return;

            face.innerHTML = renderClockSegments(data.current || 0, data.segments || 8);

            // Update narrative text based on progress
            const narrativeEl = document.getElementById('destiny-narrative');
            if (narrativeEl) {
                const progress = data.current || 0;
                const narratives = [
                    "Your destiny awaits...",
                    "You are nobody... yet.",
                    "People start to notice you.",
                    "Your name is whispered in taverns.",
                    "A legend in the making.",
                    "Your deeds echo across the land.",
                    "Heroes sing of your exploits.",
                    "The world trembles at your name.",
                    "Time to claim your destiny."
                ];
                narrativeEl.textContent = narratives[Math.min(progress, narratives.length - 1)];
            }
        }

        function displayEndgameFront(data) {
            const face = document.getElementById('endgame-front-clock-face');
            if (!face) return;

            const current = data.current || 0;
            const segments = data.segments || 8;

            face.innerHTML = renderClockSegments(current, segments);

            // Pulse animation if near full
            if (current >= segments - 2) {
                face.classList.add('threat-critical');
            } else {
                face.classList.remove('threat-critical');
            }

            // Update name
            const nameEl = document.getElementById('endgame-front-name');
            if (nameEl) {
                nameEl.textContent = data.name || "Unknown Threat";
            }
        }

        function displayQuestProgress(data) {
            const wrapper = document.getElementById('quest-progress-wrapper');
            if (!wrapper) return;

            wrapper.style.display = 'block';

            document.getElementById('quest-title').textContent = data.title || "Quest";
            document.getElementById('quest-chapter').textContent = `Chapter ${data.chapter || 1}`;
            document.getElementById('quest-progress-text').textContent = `${data.progress || 0}/${data.max_progress || 1}`;
            document.getElementById('quest-xp-earned').textContent = `XP Earned: ${data.xp_earned || 0}`;

            const progressPercent = ((data.progress || 0) / (data.max_progress || 1)) * 100;
            document.getElementById('quest-progress-bar').style.width = `${progressPercent}%`;
        }

        function hideQuestProgress() {
            const wrapper = document.getElementById('quest-progress-wrapper');
            if (wrapper) wrapper.style.display = 'none';
        }

        if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
    </script>
</body>
</html>