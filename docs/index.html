<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digital RPG: Ash-Lord's Covenant</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Crimson+Text:ital,wght@0,400;0,600;0,700;1,400&family=IM+Fell+English+SC&family=Lato:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./styles.css?v=0.9.4"> 
    
    <style>
        #character-creation-ui, #main-game-ui { display: none; }
        
        #boot-log { 
            font-family: monospace; font-size: 12px; color: #00ff00; 
            background: rgba(0,0,0,0.8); padding: 10px; border: 1px solid #333; 
            margin-top: 20px; max-height: 150px; overflow-y: auto; width: 80%; 
            text-align: left; display: none;
        }
        #force-start-btn {
            margin-top: 15px; padding: 10px 20px; background: #8A3324; color: white; 
            border: 1px solid #ff5555; border-radius: 4px; cursor: pointer; font-family: sans-serif; display: none;
        }
    </style>

    <script>
        window.showError = function(title, message) {
            var loader = document.getElementById('loading-overlay');
            if (loader) loader.style.display = 'none';
            
            var modal = document.getElementById('error-modal');
            var mTitle = document.getElementById('error-title');
            var mMsg = document.getElementById('error-message');
            
            if (modal && mTitle && mMsg) {
                mTitle.textContent = title;
                mMsg.textContent = message;
                modal.style.display = 'flex';
            } else {
                console.error("CRITICAL UI FAILURE: " + title + " - " + message);
                if (document.body) {
                    document.body.innerHTML = '<div style="color:red; padding:20px; background:black;"><h1>CRITICAL ERROR</h1><h2>' + title + '</h2><p>' + message + '</p></div>';
                } else {
                    alert("CRITICAL ERROR (DOM Not Ready): " + title + "\n" + message);
                }
            }
        };

        window.addEventListener('error', function(event) {
            try {
                window.showError("Runtime Error", event.message + " at " + event.filename + ":" + event.lineno);
            } catch (e) {
                console.error("Error Handler Failed:", e);
            }
        });
    </script>
</head>
<body class="antialiased">

    <div id="loading-overlay" class="flex fixed top-0 left-0 w-screen h-screen bg-black/80 z-[199] justify-center items-center" style="flex-direction: column;">
        <div class="spinner mb-4"></div>
        <span id="loading-text" class="ml-4 text-lg text-gray-300">Booting v0.9.5 (Hard Cutover)...</span>
        <div id="boot-log"></div>
        <button id="force-start-btn" onclick="window.forceUI()">‚ö†Ô∏è FORCE UI</button>
    </div>

    <div id="error-modal" class="fixed top-0 left-0 w-full h-full bg-black/80 z-[200] flex justify-center items-center hidden">
        <div class="modal-content bg-gray-800 border border-gray-700 p-6 rounded-lg max-w-lg w-full">
            <h2 id="error-title" class="text-xl font-bold text-red-400 mb-4">Error</h2>
            <p id="error-message" class="text-gray-300 mb-6 whitespace-pre-wrap font-mono text-sm">Something went wrong.</p>
            <button id="close-modal-btn" onclick="document.getElementById('error-modal').style.display='none'" class="w-full px-4 py-2 bg-emerald-600 text-white rounded-lg font-semibold hover:bg-emerald-700 transition">
                OK
            </button>
        </div>
    </div>

    <div id="toast-container" class="fixed top-4 right-4 z-[200] flex flex-col gap-2 pointer-events-none"></div>

    <div class="container mx-auto max-w-7xl p-4">
        <header class="mb-4 p-4 bg-gray-800 rounded-lg border border-gray-700 flex flex-col sm:flex-row justify-between items-center gap-4">
            <div>
                <h1 class="text-2xl font-bold text-white">Ash-Lord's Covenant</h1>
                <p class="text-sm text-gray-400">Digital RPG Prototype (Build v1.0.0 - Gemini 3 Pro)</p>
            </div>
            <div class="flex items-center space-x-2">
                <button onclick="window.exportSave()" class="px-3 py-2 bg-gray-700 text-xs text-gray-300 rounded-lg hover:bg-emerald-700 hover:text-white transition">
                    Export Save
                </button>
                <button onclick="window.importSave()" class="px-3 py-2 bg-gray-700 text-xs text-gray-300 rounded-lg hover:bg-emerald-700 hover:text-white transition">
                    Import Save
                </button>
                <button id="reset-game-btn" class="px-3 py-2 bg-gray-700 text-xs text-gray-300 rounded-lg hover:bg-red-700 hover:text-white transition">
                    Reset Game
                </button>
            </div>
        </header>

        <div id="character-creation-ui">
            <div class="bg-gray-800 rounded-lg border border-gray-700 shadow-lg p-6 max-w-3xl mx-auto">
                <h2 class="text-3xl font-bold text-white mb-2">Create Your Character</h2>
                <p class="text-gray-400 mb-6">Every hero in this cursed world is defined by what they do (their Calling) and what haunts them (their Burden).</p>
                
                <div class="mb-4">
                    <label for="character-name" class="block text-sm font-medium text-gray-300 mb-1">What is your name?</label>
                    <input type="text" id="character-name" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-gray-200 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <h3 class="text-xl font-semibold text-emerald-400 mb-3">Choose a Calling</h3>
                        <div id="calling-options" class="space-y-3"><p class="text-gray-500 italic">Loading data...</p></div>
                    </div>
                    <div>
                        <h3 class="text-xl font-semibold text-indigo-300 mb-3">Choose a Burden</h3>
                        <div id="burden-options" class="space-y-3"><p class="text-gray-500 italic">Loading data...</p></div>
                        
                        <div id="burden-detail-input-wrapper" class="mt-3" style="display: none;">
                            <label for="burden-detail-input" id="burden-detail-label" class="block text-sm font-medium text-gray-300 mb-1">Define your Burden:</label>
                            <input type="text" id="burden-detail-input" class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-gray-200 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500">
                        </div>
                    </div>
                </div>

                <button id="create-character-btn" class="w-full mt-6 px-4 py-3 bg-emerald-700 text-white rounded-lg font-bold hover:bg-emerald-800 shadow-md">
                    Begin Your Story
                </button>
            </div>
        </div>

        <div id="main-game-ui">
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-4">
                <div id="sidebar-container" class="lg:col-span-1 space-y-4 custom-scrollbar">
                    <div id="character-sheet-wrapper" class="bg-gray-800 rounded-lg border border-gray-700 shadow-lg">
                        <div id="character-sheet-header" class="flex justify-between items-center p-4 border-b border-gray-700 cursor-pointer">
                            <h2 class="text-xl font-semibold text-white">Character Sheet</h2>
                            <svg id="accordion-icon" class="w-6 h-6 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>
                        <div id="character-sheet-content" class="p-4 space-y-4">
                            <p id="character-sheet-loading" class="text-gray-400 italic">Loading character data...</p>
                            <div id="character-sheet-data"></div>
                        </div>
                    </div>

                    <div id="unified-clocks-wrapper" class="bg-gray-800 rounded-lg border border-gray-700 shadow-lg mt-4">
                        <div id="unified-clocks-header" class="flex justify-between items-center p-4 border-b border-gray-700 cursor-pointer hover:bg-gray-750 transition">
                            <h2 class="text-xl font-semibold text-white">World State</h2>
                            <svg id="unified-accordion-icon" class="w-6 h-6 text-gray-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                            </svg>
                        </div>

                        <div id="unified-clocks-content" class="p-4 space-y-6">
                            <div class="grid grid-cols-2 gap-2 border-b-spacers pb-8 mb-6"> 
                                <div class="flex flex-col items-center">
                                    <h4 class="text-xs uppercase text-emerald-400 font-bold tracking-wider mb-2">DESTINY</h4>
                                    <div class="clock transform scale-90">
                                        <div class="clock-face" id="destiny-clock-face"></div>
                                    </div>
                                    <p id="destiny-narrative" class="text-xs text-gray-400 text-center mt-2 font-mono leading-tight px-1">Your destiny awaits...</p>
                                </div>
                                <div class="flex flex-col items-center pl-2">
                                    <h4 class="text-xs uppercase text-red-400 font-bold tracking-wider mb-2">THE THREAT</h4>
                                    <div class="clock transform scale-90">
                                        <div class="clock-face" id="endgame-front-clock-face"></div> 
                                    </div>
                                    <span id="endgame-front-name" class="text-xs text-gray-400 text-center mt-2 font-mono leading-tight">Unknown Threat</span>
                                </div>
                            </div>

                            <div class="pt-2">
                                <h4 class="text-xs uppercase text-gray-500 mb-3 text-center font-bold tracking-widest">FACTION ACTIVITY</h4>
                                <div id="world-clocks-container" class="grid grid-cols-2 gap-4">
                                    <p id="world-clocks-loading" class="text-gray-400 italic col-span-2 text-center text-xs">Loading world state...</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div id="quest-progress-wrapper" class="bg-gray-800 rounded-lg border border-gray-700 shadow-lg p-4" style="display: none;">
                        <h2 class="text-xl font-semibold text-emerald-400 mb-2">Active Quest</h2>
                        <div id="quest-progress-content">
                            <p id="quest-title" class="font-bold text-white text-lg mb-1"></p>
                            <p id="quest-chapter" class="text-sm text-gray-400 mb-2"></p>
                            <div class="bg-gray-900 rounded p-2">
                                <div class="flex justify-between text-xs text-gray-400 mb-1">
                                    <span>Progress</span>
                                    <span id="quest-progress-text">0/0</span>
                                </div>
                                <div class="w-full bg-gray-700 rounded-full h-2">
                                    <div id="quest-progress-bar" class="bg-emerald-600 h-2 rounded-full transition-all" style="width: 0%"></div>
                                </div>
                            </div>
                            <p id="quest-xp-earned" class="text-xs text-gray-400 mt-2"></p>
                        </div>
                    </div>
                </div>

                <div class="lg:col-span-2 flex flex-col h-[80vh]">
                    <div class="flex-grow bg-gray-800 rounded-lg border border-gray-700 shadow-lg p-4 overflow-y-auto" id="narrative-log"></div>

                    <div id="interaction-panel" class="mt-4 bg-gray-800 rounded-lg border border-gray-700 shadow-lg p-4">
                        <div id="chapter-phase-ui">
                            <textarea id="player-input" 
                                      class="w-full p-3 bg-gray-900 border border-gray-700 rounded-lg text-gray-200 placeholder-gray-500 focus:outline-none focus:ring-2 focus:ring-emerald-500" 
                                      rows="3" 
                                      placeholder="Describe your character's action..."></textarea>
                            
                            <button id="submit-action-btn" class="w-full mt-3 px-4 py-3 bg-emerald-700 text-white rounded-lg font-bold hover:bg-emerald-800 shadow-md">
                                Submit Action
                            </button>
                            
                            <p class="text-xs text-gray-500 text-center mt-2">Press <kbd class="px-1 bg-gray-700 rounded">Enter</kbd> to submit (Shift+Enter for new line)</p>
                        </div>
                        
                        <div id="interlude-phase-ui" class="hidden">
                            <p class="text-lg text-gray-300 mb-4">You have a moment for an Interlude. What is your priority?</p>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                                <button id="interlude-train-btn" class="interlude-button">Seek Training (1 XP)</button>
                                <button id="interlude-asset-btn" class="interlude-button">Acquire an Asset (1 XP)</button>
                                <button id="interlude-reflect-btn" class="interlude-button">Reflect & Integrate (1 XP)</button>
                                <button id="interlude-end-btn" class="interlude-button end-interlude">End Interlude</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load game data first (no module required) -->
    <script src="./game_data.js"></script>

    <script>
        // ===== STATE MANAGER (Inlined for local file:// compatibility) =====

        const GAME_STATE_KEY = "ashlords_game_v1";
        const BACKUP_KEY = "ashlords_game_v1_backup";

        const createFreshState = () => ({
            version: "1.0.0",
            userId: `local-${crypto.randomUUID()}`,
            character: null,
            gameState: {
                phase: "character_creation",
                turn_count: 0,
                saga_log: "The story begins...",
                current_location: "Unknown"
            },
            chatHistory: [],
            worldClocks: { clocks: [] },
            destinyFrontClocks: {
                destiny: { current: 0, segments: 8 },
                front: { current: 0, segments: 8, name: "The Threat Looms" }
            },
            questState: { current_quest: null },
            campaign: null
        });

        class StateValidator {
            static validate(updates, currentState) {
                const errors = [];
                if (updates.character) {
                    const char = updates.character;
                    if (char.stats) {
                        for (const [stat, val] of Object.entries(char.stats)) {
                            if (val < -3 || val > 5) {
                                errors.push(`Stat ${stat} out of bounds: ${val}`);
                            }
                        }
                    }
                    if (char.pips) {
                        for (const [stat, pips] of Object.entries(char.pips)) {
                            if (pips < 0 || pips > 2) {
                                errors.push(`Pips ${stat} out of bounds: ${pips}`);
                            }
                        }
                    }
                    if (char.currency !== undefined && char.currency < 0) {
                        errors.push(`Currency cannot be negative: ${char.currency}`);
                    }
                    if (char.xp !== undefined && char.xp < 0) {
                        errors.push(`XP cannot be negative: ${char.xp}`);
                    }
                }
                if (updates.chatHistory && updates.chatHistory.length > 30) {
                    errors.push(`Chat history exceeds 30 messages`);
                }
                if (errors.length > 0) {
                    throw new Error("Validation failed:\n" + errors.join("\n"));
                }
                return true;
            }
        }

        class ErrorRecovery {
            static recoverState() {
                try {
                    const stateStr = localStorage.getItem(GAME_STATE_KEY);
                    if (stateStr) {
                        const state = JSON.parse(stateStr);
                        if (this.validateStructure(state)) {
                            console.log("‚úÖ Loaded state from localStorage");
                            return state;
                        }
                    }
                } catch (e) {
                    console.error("‚ùå Main state corrupted:", e);
                }
                try {
                    const backupStr = localStorage.getItem(BACKUP_KEY);
                    if (backupStr) {
                        const backup = JSON.parse(backupStr);
                        if (this.validateStructure(backup)) {
                            console.warn("‚ö†Ô∏è Recovered from backup state");
                            return backup;
                        }
                    }
                } catch (e) {
                    console.error("‚ùå Backup state corrupted:", e);
                }
                console.log("üÜï Creating fresh state");
                return createFreshState();
            }

            static validateStructure(state) {
                return state && state.version && state.userId && state.gameState && Array.isArray(state.chatHistory);
            }

            static createBackup(state) {
                try {
                    localStorage.setItem(BACKUP_KEY, JSON.stringify(state));
                } catch (e) {
                    console.error("Failed to create backup:", e);
                }
            }
        }

        class TransactionQueue {
            constructor(stateManager) {
                this.stateManager = stateManager;
                this.queue = [];
                this.processing = false;
            }

            async enqueue(transaction) {
                return new Promise((resolve, reject) => {
                    this.queue.push({ transaction, resolve, reject });
                    this.processNext();
                });
            }

            async processNext() {
                if (this.processing || this.queue.length === 0) return;
                this.processing = true;
                const { transaction, resolve, reject } = this.queue.shift();
                try {
                    const updates = await transaction(this.stateManager.state);
                    const result = await this.stateManager.updateState(updates);
                    resolve(result);
                } catch (error) {
                    console.error("Transaction failed:", error);
                    reject(error);
                } finally {
                    this.processing = false;
                    this.processNext();
                }
            }
        }

        class GameStateManager {
            constructor() {
                this.state = ErrorRecovery.recoverState();
                this.listeners = new Map();
                this.txQueue = new TransactionQueue(this);
                ErrorRecovery.createBackup(this.state);
            }

            subscribe(key, callback) {
                if (!this.listeners.has(key)) {
                    this.listeners.set(key, new Set());
                }
                this.listeners.get(key).add(callback);
                // Always call callback immediately with current state (even if null)
                const slice = this.getStateSlice(key);
                callback(slice);
            }

            unsubscribe(key, callback) {
                this.listeners.get(key)?.delete(callback);
            }

            async updateState(updates) {
                try {
                    StateValidator.validate(updates, this.state);
                    const newState = this.deepMerge(this.state, updates);
                    localStorage.setItem(GAME_STATE_KEY, JSON.stringify(newState));
                    if (newState.gameState?.turn_count % 5 === 0) {
                        ErrorRecovery.createBackup(newState);
                    }
                    this.state = newState;
                    this.notifySubscribers(updates);
                    return { success: true };
                } catch (error) {
                    console.error("State update failed:", error);
                    return { success: false, error: error.message };
                }
            }

            deepMerge(target, source) {
                const output = { ...target };
                for (const key in source) {
                    if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
                        output[key] = this.deepMerge(target[key] || {}, source[key]);
                    } else {
                        output[key] = source[key];
                    }
                }
                return output;
            }

            notifySubscribers(updates) {
                for (const [key, callbacks] of this.listeners) {
                    if (this.wasKeyAffected(key, updates)) {
                        const slice = this.getStateSlice(key);
                        callbacks.forEach(cb => {
                            try { cb(slice); } catch (e) { console.error(`Listener error for ${key}:`, e); }
                        });
                    }
                }
            }

            wasKeyAffected(key, updates) {
                return key in updates || key === 'all';
            }

            getStateSlice(key) {
                switch(key) {
                    case 'character': return this.state.character;
                    case 'chatHistory': return this.state.chatHistory;
                    case 'worldClocks': return this.state.worldClocks;
                    case 'destinyFrontClocks': return this.state.destinyFrontClocks;
                    case 'gameState': return this.state.gameState;
                    case 'questState': return this.state.questState;
                    case 'all': return this.state;
                    default: return null;
                }
            }

            getState() { return this.state; }
            async transaction(fn) { return this.txQueue.enqueue(fn); }
            exportState() { return JSON.stringify(this.state, null, 2); }

            importState(stateJson) {
                try {
                    const imported = JSON.parse(stateJson);
                    if (ErrorRecovery.validateStructure(imported)) {
                        this.state = imported;
                        localStorage.setItem(GAME_STATE_KEY, stateJson);
                        ErrorRecovery.createBackup(imported);
                        this.notifySubscribers({ all: true });
                        return true;
                    }
                    return false;
                } catch (e) {
                    console.error("Import failed:", e);
                    return false;
                }
            }

            reset() {
                this.state = createFreshState();
                localStorage.setItem(GAME_STATE_KEY, JSON.stringify(this.state));
                localStorage.removeItem(BACKUP_KEY);
                this.notifySubscribers({ all: true });
            }
        }

        const gameState = new GameStateManager();

        // ===== GAME CODE =====
        // Note: CONTENT_PACK_ASHLORDS is loaded from game_data.js script tag

        const ui = {}; 

        function logBoot(msg) {
            console.log(msg);
            const el = document.getElementById('boot-log');
            if(el) {
                el.style.display = 'block';
                el.innerHTML += `<div>> ${msg}</div>`;
            }
        }

        async function init() {
            logBoot("üöÄ INIT SEQUENCE v1.0.0 (localStorage + Gemini 3 Pro)");

            setTimeout(() => {
                const btn = document.getElementById('force-start-btn');
                if(btn) btn.style.display = 'block';
            }, 5000);

            try {
                bindUI();
            } catch (e) {
                window.showError("UI Error", "Failed to bind UI. " + e.message);
                return;
            }

            try {
                logBoot("Step 1: Checking Game Data...");
                // Game data is loaded via script tag (no module import needed)
                if (typeof CONTENT_PACK_ASHLORDS === 'undefined') {
                    throw new Error("Game data not loaded. Make sure game_data.js is present.");
                }
                logBoot("‚úÖ Data Loaded.");

            } catch (e) {
                logBoot(`‚ùå DATA ERROR: ${e.message}`);
                window.showError("Initialization Error", `Failed to load game data. ${e.message}`);
                return;
            }

            try {
                logBoot("Step 2: Setting up state listeners...");
                setupStateListeners();
                logBoot("‚úÖ State listeners ready.");
                hideLoading();
            } catch (e) {
                logBoot(`‚ùå SETUP ERROR: ${e.message}`);
                window.showError("Setup Error", e.message);
            }
        }

        function bindUI() {
            const safeBind = (id) => document.getElementById(id);

            ui.loading = safeBind('loading-overlay');
            ui.charCreation = safeBind('character-creation-ui');
            ui.mainGame = safeBind('main-game-ui');
            ui.callingOpts = safeBind('calling-options');
            ui.burdenOpts = safeBind('burden-options');
            ui.burdenDetailWrap = safeBind('burden-detail-input-wrapper');
            ui.burdenDetailInput = safeBind('burden-detail-input');
            ui.burdenDetailLabel = safeBind('burden-detail-label');
            ui.charName = safeBind('character-name');
            ui.playerInput = safeBind('player-input');
            ui.modal = safeBind('error-modal');
            ui.characterSheetLoading = safeBind('character-sheet-loading');
            ui.worldClocksContainer = safeBind('world-clocks-container');
            ui.chapterUI = safeBind('chapter-phase-ui');
            ui.interludeUI = safeBind('interlude-phase-ui');
            
            const btnCreate = safeBind('create-character-btn');
            if (btnCreate) btnCreate.addEventListener('click', createCharacterAndStartGame);
            
            const btnSubmit = safeBind('submit-action-btn');
            if (btnSubmit) btnSubmit.addEventListener('click', handlePlayerAction);
            
            const btnReset = safeBind('reset-game-btn');
            if (btnReset) btnReset.addEventListener('click', resetGame);
            
            const btnTrain = safeBind('interlude-train-btn');
            if (btnTrain) btnTrain.addEventListener('click', () => handleInterludeAction('seek_training'));
            
            const btnAsset = safeBind('interlude-asset-btn');
            if (btnAsset) btnAsset.addEventListener('click', () => handleInterludeAction('acquire_asset'));
            
            const btnReflect = safeBind('interlude-reflect-btn');
            if (btnReflect) btnReflect.addEventListener('click', () => handleInterludeAction('reflect'));
            
            const btnEnd = safeBind('interlude-end-btn');
            if (btnEnd) btnEnd.addEventListener('click', () => handleInterludeAction('end_interlude'));

            if(ui.playerInput) ui.playerInput.addEventListener('keydown', (e) => { if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handlePlayerAction(); } });
            
            const btnCloseModal = safeBind('close-modal-btn');
            if(btnCloseModal && ui.modal) {
                 btnCloseModal.addEventListener('click', () => {
                    ui.modal.style.display = 'none';
                 });
            }

            const toggleAccordion = (headerId, contentId, iconId) => {
                const header = document.getElementById(headerId);
                const content = document.getElementById(contentId);
                const icon = document.getElementById(iconId);
                if(header && content) {
                    header.onclick = () => {
                        const isHidden = content.style.display === 'none';
                        content.style.display = isHidden ? 'block' : 'none';
                        if(icon) icon.style.transform = isHidden ? 'rotate(0deg)' : 'rotate(-90deg)';
                    };
                }
            };
            toggleAccordion('character-sheet-header', 'character-sheet-content', 'accordion-icon');
            toggleAccordion('unified-clocks-header', 'unified-clocks-content', 'unified-accordion-icon');

            window.forceUI = () => {
                if(ui.loading) ui.loading.style.display = 'none';
                if(ui.charCreation) ui.charCreation.style.display = 'block';
                renderOptions();
            };
        }

        function setupStateListeners() {
            // Character updates
            gameState.subscribe('character', (character) => {
                logBoot("üì° Character Update");
                if (character) {
                    ui.charCreation.style.display = 'none';
                    ui.mainGame.style.display = 'block';
                    displayCharacter(character);
                } else {
                    ui.mainGame.style.display = 'none';
                    ui.charCreation.style.display = 'block';
                    renderOptions();
                }
            });

            // Chat history updates
            gameState.subscribe('chatHistory', (chatHistory) => {
                displayChatHistory(chatHistory || []);
            });

            // World clocks
            gameState.subscribe('worldClocks', (worldClocks) => {
                if (worldClocks) displayWorldClocks(worldClocks);
            });

            // Destiny and Front clocks
            gameState.subscribe('destinyFrontClocks', (clocks) => {
                if (clocks) {
                    displayDestinyClock(clocks.destiny);
                    displayEndgameFront(clocks.front);
                }
            });

            // Quest state
            gameState.subscribe('questState', (questState) => {
                if (questState?.current_quest) {
                    displayQuestProgress(questState.current_quest);
                } else {
                    hideQuestProgress();
                }
            });

            // Game state (phase changes)
            gameState.subscribe('gameState', (state) => {
                if (state) {
                    if (state.phase === 'interlude') {
                        ui.chapterUI.style.display = 'none';
                        ui.interludeUI.style.display = 'block';
                    } else {
                        ui.chapterUI.style.display = 'block';
                        ui.interludeUI.style.display = 'none';
                    }
                }
            });
        }

        function renderOptions() {
            const createStatLine = (stats) => {
                const positive = Object.entries(stats).filter(([, v]) => v > 0);
                const negative = Object.entries(stats).filter(([, v]) => v < 0);
                
                const format = ([k, v]) => {
                    const sign = v > 0 ? '+' : '';
                    const colorClass = v > 0 ? 'text-emerald-400' : 'text-gray-500';
                    return `<span class="${colorClass}">${k.toUpperCase()} ${sign}${v}</span>`;
                };
                
                const posStr = positive.map(format).join(' / ');
                const negStr = negative.map(format).join(' / ');
                
                if (posStr && negStr) return `${posStr} / ${negStr}`;
                return posStr || negStr;
            };
                
            if (ui.callingOpts) {
                ui.callingOpts.innerHTML = '';
                CONTENT_PACK_ASHLORDS.callings.forEach(c => {
                    const tHtml = (c.talents||[]).map(t=>`<div><b class="text-gray-300">${t.name}</b>: <span class="text-gray-400 text-xs">${t.description}</span></div>`).join('');
                    const card = document.createElement('div');
                    card.className = 'playbook-card p-4 rounded-lg cursor-pointer border border-gray-700 mb-2';
                    card.dataset.id = c.id;
                    card.innerHTML = `<h4 class="text-white font-bold">${c.name}</h4><p class="text-gray-400 text-sm mb-2">${c.description}</p><div class="text-xs font-mono mb-2">${createStatLine(c.stats)}</div><div class="space-y-1">${tHtml}</div>`;
                    card.onclick = () => { if(ui.callingOpts) Array.from(ui.callingOpts.children).forEach(x=>x.classList.remove('selected')); card.classList.add('selected'); };
                    ui.callingOpts.appendChild(card);
                });
            }

            if (ui.burdenOpts) {
                ui.burdenOpts.innerHTML = '';
                CONTENT_PACK_ASHLORDS.burdens.forEach(b => {
                    const tHtml = (b.talents||[]).map(t=>`<div><b class="text-gray-300">${t.name}</b>: <span class="text-gray-400 text-xs">${t.description}</span></div>`).join('');
                    const card = document.createElement('div');
                    card.className = 'playbook-card p-4 rounded-lg cursor-pointer border border-gray-700 mb-2';
                    card.dataset.id = b.id;
                    card.dataset.requiresInput = b.requiresInput;
                    card.innerHTML = `<h4 class="text-white font-bold">${b.name}</h4><p class="text-gray-400 text-sm mb-2">${b.description}</p><div class="text-xs font-mono mb-2">${createStatLine(b.stats)}</div><div class="space-y-1">${tHtml}</div>`;
                    card.onclick = () => {
                        if(ui.burdenOpts) Array.from(ui.burdenOpts.children).forEach(x=>x.classList.remove('selected')); card.classList.add('selected');
                        if(ui.burdenDetailWrap) ui.burdenDetailWrap.style.display = b.requiresInput ? 'block' : 'none';
                        if(b.requiresInput && ui.burdenDetailLabel) ui.burdenDetailLabel.textContent = b.inputLabel || "Define details:";
                    };
                    ui.burdenOpts.appendChild(card);
                });
            }
        }

        function displayCharacter(data) {
            const sheet = document.getElementById('character-sheet-data');
            if (!sheet) return;
            if(ui.characterSheetLoading) ui.characterSheetLoading.style.display = 'none';
            
            if(CONTENT_PACK_ASHLORDS && data.playbook) {
                const callingName = data.playbook?.calling;
                const callingObj = callingName ? CONTENT_PACK_ASHLORDS.callings.find(c => c.name === callingName) : null;
                
                if(callingObj) {
                    const questData = CONTENT_PACK_ASHLORDS.LEGENDARY_QUESTS ? CONTENT_PACK_ASHLORDS.LEGENDARY_QUESTS[callingObj.id] : null;
                    const destinyText = document.getElementById('destiny-narrative');
                    if(questData && destinyText) {
                        destinyText.textContent = questData.title; 
                        destinyText.style.color = "var(--c-alchemical-gold)";
                    }
                }
            }

            const pipsData = data.pips || {}; 
            
            const statsHtml = Object.entries(data.stats || {}).map(([k,v]) => {
                const pipCount = pipsData[k] || 0;
                const pip1Class = pipCount >= 1 ? "filled" : "";
                const pip2Class = pipCount >= 2 ? "filled" : "";
                
                return `
                <div class="stat-block p-2 text-center border border-gray-700 rounded hover:bg-gray-700" onclick="updateDescription('${k}', 'Pips: ${pipCount}/2', 'stat')">
                    <div class="text-xs text-gray-400 uppercase">${k.substring(0,3)}</div>
                    <div class="text-xl font-bold ${v>0?'text-emerald-400':'text-gray-300'}">${v>0?'+'+v:v}</div>
                    <div class="pip-container">
                        <div class="pip ${pip1Class}"></div>
                        <div class="pip ${pip2Class}"></div>
                    </div>
                </div>`;
            }).join('');
            
            const escapeStr = (str) => str.replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, ' ');

            const talentsHtml = (data.talents||[]).map(t=> {
                return `<div class="talent-block p-2 border border-gray-700 rounded text-center hover:border-emerald-500" onclick="updateDescription('${escapeStr(t.name)}', '${escapeStr(t.description)}', 'talent')"><span class="text-sm text-gray-300">${t.name}</span></div>`
            }).join('');
            
            const equipHtml = (data.equipment || []).map(i => {
                const safeProperties = (i.properties || []).filter(p => p);
                const badges = safeProperties.map(p => {
                    if (typeof p !== 'string') return '';
                    const type = p.toLowerCase().includes('heavy') ? 'heavy' : 
                                 p.toLowerCase().includes('silver') || p.toLowerCase().includes('gold') || p.toLowerCase().includes('precious') ? 'precious' :
                                 p.toLowerCase().includes('consumable') ? 'consumable' :
                                 p.toLowerCase().includes('fragile') || p.toLowerCase().includes('shabby') ? 'fragile' : '';
                    return `<span class="equip-tag ${type}">${p}</span>`;
                }).join(' '); 
                
                const safeName = (i.name || 'Unknown Item').replace(/'/g, "&apos;");
                const loreContent = (i.lore || '').replace(/'/g, "\\'").replace(/"/g, '&quot;').replace(/\n/g, '\\n'); 
                
                return `<li class="text-sm text-gray-300 py-2 border-b border-gray-800 cursor-pointer hover:text-emerald-400 flex justify-between items-center" onclick="updateDescription('${safeName}', '', 'item', '${loreContent}')">
                    <span>${i.name}</span>
                    <div class="text-right">${badges}</div>
                </li>`;
            }).join('');
            
            // UI UPDATE (v0.9.5): Removed the Conditions container div
            sheet.innerHTML = `
                <div class="space-y-4">
                    <div class="flex justify-between items-end">
                        <div>
                            <h3 class="text-xl font-bold text-white">${data.name || "Unknown"}</h3>
                            <p class="text-sm text-emerald-400">${data.playbook?.calling || "?"} / ${data.playbook?.burden || "?"}</p>
                        </div>
                        <div class="text-right flex items-center space-x-4">
                             <div>
                                 <p class="text-xs text-gray-500">EXP</p>
                                 <p class="text-lg font-bold text-emerald-400">${data.xp || 0}</p>
                             </div>
                             <div>
                                 <p class="text-xs text-gray-500">COIN</p>
                                 <p class="text-lg font-bold text-emerald-400">${data.currency || 0}</p>
                             </div>
                        </div>
                    </div>
                    <div class="grid grid-cols-5 gap-2 select-none">${statsHtml}</div>
                    <div>
                        <h4 class="text-xs uppercase font-semibold text-gray-500 mb-2 tracking-wider">Talents</h4>
                        <div class="grid grid-cols-2 gap-2">${talentsHtml || '<p class="text-sm text-gray-500 italic col-span-2">No talents.</p>'}</div>
                    </div>
                    <div>
                        <h4 class="text-xs uppercase font-semibold text-gray-500 mb-2 tracking-wider">Equipment</h4>
                        <ul class="space-y-0">${equipHtml || '<span class="text-gray-500 text-xs">None</span>'}</ul>
                    </div>
                    <div id="description-display" class="text-sm text-left text-gray-400 min-h-[3.5em] p-3 bg-gray-900 rounded-r-lg flex flex-col justify-center mt-2 border-t-2 border-gray-800">
                        <span class="italic opacity-50">Select any attribute, talent, or item above to view details.</span>
                    </div>
                </div>`;
        }

        window.updateDescription = (title, description, type, lore = '') => {
            const display = document.getElementById('description-display');
            if(display) {
                let content = `<strong class="text-emerald-400 block mb-1">${title}</strong>`;
                if(description) content += `<p class="text-gray-400 text-sm mb-2">${description}</p>`;
                if (lore) content += `<div class="mt-2 pt-2 border-t border-gray-700 font-mono text-xs text-red-300">${lore.replace(/\\n/g, '<br>')}</div>`;
                
                display.innerHTML = content;
                display.classList.remove('active');
                void display.offsetWidth; 
                display.classList.add('active');
            }
        };

        async function createCharacterAndStartGame() {
            const charName = ui.charName.value.trim();
            const selectedCallingEl = ui.callingOpts.querySelector('.selected');
            const selectedBurdenEl = ui.burdenOpts.querySelector('.selected');

            if (!charName || !selectedCallingEl || !selectedBurdenEl) {
                return window.showError("Missing Info", "Please fill all fields.");
            }

            showLoading();

            try {
                const callingId = selectedCallingEl.dataset.id;
                const burdenId = selectedBurdenEl.dataset.id;
                const calling = CONTENT_PACK_ASHLORDS.callings.find(c => c.id === callingId);
                const burden = CONTENT_PACK_ASHLORDS.burdens.find(b => b.id === burdenId);

                const combinedStats = { FORCE: 0, FINESSE: 0, INFLUENCE: 0, WITS: 0, RESOLVE: 0 };
                for (const stat in combinedStats) {
                    combinedStats[stat] = (calling.stats[stat] || 0) + (burden.stats[stat] || 0);
                }

                const newCharacter = {
                    name: charName,
                    playbook: { calling: calling.name, burden: burden.name },
                    stats: combinedStats,
                    pips: {},
                    talents: [...(calling.talents || []), ...(burden.talents || [])],
                    equipment: [...(calling.equipment || []), ...(burden.equipment || [])],
                    xp: 0,
                    xp_locked: 0,
                    currency: 0
                };

                // Get front name from calling
                const fronts = CONTENT_PACK_ASHLORDS.endgame_fronts || {};
                const frontInfo = fronts[callingId];

                // Initialize world clocks
                const clockData = (CONTENT_PACK_ASHLORDS.FACTIONS || []).map(f => ({
                    name: f.name,
                    current: 0,
                    segments: 6,
                    goal: f.goal || "Advance Agenda"
                }));

                // Update state atomically
                await gameState.transaction(async (state) => ({
                    character: newCharacter,
                    gameState: {
                        phase: 'adventure',
                        turn_count: 0,
                        saga_log: "The story begins...",
                        current_location: "The Tavern"
                    },
                    worldClocks: {
                        clocks: clockData
                    },
                    destinyFrontClocks: {
                        destiny: { current: 0, segments: 8 },
                        front: {
                            current: 0,
                            segments: 8,
                            name: frontInfo?.name || "The Threat Looms"
                        }
                    },
                    campaign: {
                        id: "ashlords_covenant_main_v1",
                        started_at: Date.now(),
                        active: true,
                        version: "1.0.0"
                    },
                    chatHistory: [{
                        role: 'model',
                        content: "You are in a dimly lit tavern, the air thick with stale ale and desperation. Ash-Warden enforcers, clad in rusted, reinforced plate armor, are shaking down the tavern keeper over a fabricated 'Blight Tax'. One guard, his face a mask of bored cruelty beneath a grim iron visor, shoves the old man. 'Pay up, or we shut you down.' What do you do?",
                        timestamp: Date.now(),
                        id: crypto.randomUUID()
                    }]
                }));

            } catch (error) {
                window.showError("Creation Failed", error.message);
            } finally {
                hideLoading();
            }
        }

        async function handlePlayerAction() {
            const text = ui.playerInput.value.trim();
            if (!text) return;

            ui.playerInput.value = '';
            ui.playerInput.disabled = true;
            document.getElementById('submit-action-btn').disabled = true;
            showLoading();

            try {
                // Add user message
                await addMessageToChat('user', text);

                // Call AI (now returns parsed JSON directly)
                const aiResponse = await callAIGM(text);

                // Add AI narrative
                if (aiResponse.narrative) {
                    await addMessageToChat('model', aiResponse.narrative);
                }

                // Process state updates
                if (aiResponse.state_update) {
                    await processStateUpdate(aiResponse.state_update);
                }

                // Update location
                if (aiResponse.location_update) {
                    await gameState.transaction(async (state) => ({
                        gameState: {
                            ...state.gameState,
                            current_location: aiResponse.location_update
                        }
                    }));
                    showToast(`Location: ${aiResponse.location_update}`);
                }

                // Increment turn count
                await gameState.transaction(async (state) => ({
                    gameState: {
                        ...state.gameState,
                        turn_count: (state.gameState?.turn_count || 0) + 1
                    }
                }));

            } catch (e) {
                console.error("Action Error:", e);
                window.showError("GM Response Error", e.message);
            } finally {
                ui.playerInput.disabled = false;
                ui.playerInput.focus();
                document.getElementById('submit-action-btn').disabled = false;
                hideLoading();
            }
        }

        async function callAIGM(playerInput) {
            // ‚ö†Ô∏è REPLACE THIS URL WITH YOUR CLOUDFLARE WORKER URL AFTER DEPLOYMENT
            const PROXY_URL = 'https://ash-lords-rpg-proxy.jweisgrau.workers.dev';

            const state = gameState.getState();
            const character = state.character;
            const chatHistory = state.chatHistory || [];

            // Use last 10 messages for AI context (optimized)
            const recentMessages = chatHistory.slice(-10);

            // Build conversation context
            const conversationContext = recentMessages
                .map(m => `${m.role.toUpperCase()}: ${m.content}`)
                .join('\n\n');

            // Calculate pip penalties
            const pipsData = character.pips || {};
            let pipContext = "";
            let mathContext = "";

            Object.entries(pipsData).forEach(([stat, count]) => {
                if (count > 0) {
                    mathContext += `[SYSTEM NOTE]: ${stat} has ${count} Pips (Strain/Injury). Penalty: -${count} to Roll.\n`;
                    pipContext += `${stat}: ${count} Pips (Penalty -${count}). `;
                }
            });

            // Virtual d10 roll
            const virtualD10 = Math.floor(Math.random() * 10) + 1;

            const heroContext = `*** HERO CONTEXT ***
NAME: ${character.name}
CALLING: ${character.playbook?.calling} / BURDEN: ${character.playbook?.burden}
STATS: FORCE: ${character.stats.FORCE}, FINESSE: ${character.stats.FINESSE}, INFLUENCE: ${character.stats.INFLUENCE}, WITS: ${character.stats.WITS}, RESOLVE: ${character.stats.RESOLVE}
PIPS (DAMAGE): ${pipContext || "None"}
TALENTS: ${(character.talents||[]).map(t=>t.name).join(', ')}
EQUIPMENT: ${(character.equipment||[]).map(e=>e.name).join(', ')}
CURRENT COIN: ${character.currency}`;

            const systemPrompt = `*** IDENTITY ***
You are the AI GM for "The Ash-Lord's Covenant". Grimdark political fantasy.

${heroContext}

*** LOCATION CONTEXT ***
CURRENT LOCATION: ${state.gameState?.current_location || "Unknown"}

*** RECENT CONVERSATION ***
${conversationContext}

*** MECHANICS (d10 + STAT - PIPS) ***
** VIRTUAL D10 ROLL: [ ${virtualD10} ] **
${mathContext}

*** CRITICAL RULES ***
1. DAMAGE SYSTEM (PIPS):
   - Strain (1 Pip): Minor harm, clears with rest/payment
   - Injury (2 Pips): Serious harm, requires 3+ coin or special item
   - **MAX 2 PIPS PER STAT** - If already at 2 Pips and would take more, character is INCAPACITATED
   - **ALWAYS mention pip changes in narrative**

2. PIP PENALTIES:
   - Roll formula: d10 + STAT - PIPS
   - Example: FORCE +2 with 1 Pip = d10(${virtualD10}) + 2 - 1 = total

3. TIER ENFORCEMENT:
   - Tier 1 (Challenging): 6+ Success, 4-5 Cost, 1-3 Miss
     * Cost: Minor complication OR 1 Pip Strain
   - Tier 2 (Perilous): 7+ Success, 5-6 Cost, 1-4 Miss
     * Cost: Serious complication OR 2 Pips Injury
   - **Combat is always Tier 2** - Apply injury on Cost/Miss

4. CURRENCY MECHANICS:
   - Current: ${character.currency} coin
   - **When player spends/gives coin: ONLY use "currency_gain": -X (negative number)**
   - **Do NOT use remove_pips when player gives/spends coin on non-healing things**
   - Examples:
     * Bribe guard (2 coin) ‚Üí "currency_gain": -2 (NO remove_pips)
     * Tip barkeep (1 coin) ‚Üí "currency_gain": -1 (NO remove_pips)
     * Buy item (3 coin) ‚Üí "currency_gain": -3 (NO remove_pips)
     * Pay for healing (3 coin) ‚Üí "currency_gain": -3 AND "remove_pips": {"stat": "FORCE", "amount": 1}

5. HEALING MECHANICS:
   - Pips NEVER clear automatically
   - **Only use remove_pips when player is ACTIVELY BEING HEALED**
   - Healing requires: 3+ coin payment OR narrative rest scene OR use healing item
   - **NEVER heal pips just because player gave money to someone**

6. CONSEQUENCES ALWAYS APPLY:
   - Never give "free success" - apply cost on 4-6
   - Grimdark = choices have weight

*** OUTPUT FORMAT (JSON ONLY) ***
You MUST respond with valid JSON in this exact structure:
{
  "narrative": "Story text... <mechanics>Action: [Stat] (Tier X). Roll: d10(${virtualD10}) + Stat(X) - Pips(X) = Total. Result: [Success/Cost/Miss]</mechanics>",
  "location_update": "New Location Name (optional)",
  "state_update": {
    "xp_gain": 0,
    "currency_gain": 0,
    "add_pips": {"stat": "FORCE", "amount": 1},
    "remove_pips": {"stat": "FORCE", "amount": 1},
    "equipment_add": [],
    "item_modify": [],
    "clocks_advance": []
  }
}

**IMPORTANT:**
- stat must be one of: FORCE, FINESSE, INFLUENCE, WITS, RESOLVE
- amount for pips must be 1 or 2 only
- currency_gain can be negative for payments (use ONLY this for spending money)
- remove_pips should ONLY be used when player is being healed, NOT when just giving/spending coin
- If player gives coin as tip/bribe/gift: use currency_gain: -X, leave remove_pips empty`;

            // Build Gemini payload
            const payload = {
                contents: [
                    {
                        role: 'user',
                        parts: [{ text: systemPrompt }]
                    },
                    ...recentMessages.map(m => ({
                        role: m.role === 'model' ? 'model' : 'user',
                        parts: [{ text: m.content }]
                    })),
                    {
                        role: 'user',
                        parts: [{ text: playerInput }]
                    }
                ],
                generationConfig: {
                    responseMimeType: "application/json",
                    temperature: 0.9,
                    topP: 0.95
                }
            };

            // Retry logic with exponential backoff
            let attempts = 0;
            const maxAttempts = 3;

            while (attempts < maxAttempts) {
                try {
                    const response = await fetch(PROXY_URL, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            model: "gemini-3-pro",
                            payload: payload
                        })
                    });

                    if (response.status === 429 || response.status === 503) {
                        console.warn(`API ${response.status}. Retrying (${attempts + 1}/${maxAttempts})...`);
                        attempts++;
                        await new Promise(r => setTimeout(r, 2000 * attempts));
                        continue;
                    }

                    if (!response.ok) {
                        const errText = await response.text();
                        throw new Error(`API HTTP ${response.status}: ${errText}`);
                    }

                    const data = await response.json();

                    // Extract JSON from Gemini response
                    const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
                    if (!text) {
                        throw new Error("Gemini did not return text");
                    }

                    // Parse JSON (Gemini should return clean JSON with responseMimeType)
                    let parsed;
                    try {
                        parsed = JSON.parse(text);
                    } catch (e) {
                        // Fallback: try to extract JSON from text
                        const start = text.indexOf('{');
                        const end = text.lastIndexOf('}');
                        if (start !== -1 && end !== -1) {
                            parsed = JSON.parse(text.substring(start, end + 1));
                        } else {
                            throw new Error("Could not parse JSON from Gemini response: " + text);
                        }
                    }

                    return parsed;

                } catch (e) {
                    if (attempts === maxAttempts - 1) throw e;
                    attempts++;
                    await new Promise(r => setTimeout(r, 2000 * attempts));
                }
            }
        }
        
        async function processStateUpdate(update) {
            if (!update) return;

            await gameState.transaction(async (state) => {
                const character = state.character;
                const updates = {};

                // XP gain
                if (update.xp_gain) {
                    updates.character = {
                        ...character,
                        xp: (character.xp || 0) + update.xp_gain
                    };
                    showToast(`+${update.xp_gain} XP`);
                }

                // Currency gain/loss
                if (update.currency_gain) {
                    const newCurrency = Math.max(0, (character.currency || 0) + update.currency_gain);
                    updates.character = {
                        ...(updates.character || character),
                        currency: newCurrency
                    };
                    showToast(`${update.currency_gain > 0 ? '+' : ''}${update.currency_gain} Coin`);
                }

                // Pips
                let currentPips = { ...(character.pips || {}) };
                let pipChanged = false;

                if (update.add_pips) {
                    const stat = update.add_pips.stat;
                    const amt = update.add_pips.amount || 1;
                    currentPips[stat] = Math.min(2, (currentPips[stat] || 0) + amt);
                    pipChanged = true;
                    showToast(`${stat} damage: +${amt} pip${amt > 1 ? 's' : ''}`);
                }

                if (update.remove_pips) {
                    const stat = update.remove_pips.stat;
                    const amt = update.remove_pips.amount || 1;
                    currentPips[stat] = Math.max(0, (currentPips[stat] || 0) - amt);
                    pipChanged = true;
                    showToast(`${stat} healed: -${amt} pip${amt > 1 ? 's' : ''}`);
                }

                if (pipChanged) {
                    updates.character = {
                        ...(updates.character || character),
                        pips: currentPips
                    };
                }

                // Equipment add
                if (update.equipment_add && update.equipment_add.length > 0) {
                    const currentEquipment = character.equipment || [];
                    const newItems = update.equipment_add.map(item => ({
                        name: item.name || "Unknown Item",
                        properties: item.properties || [],
                        lore: item.lore || ""
                    }));

                    updates.character = {
                        ...(updates.character || character),
                        equipment: [...currentEquipment, ...newItems]
                    };

                    newItems.forEach(item => showToast(`+1 Item: ${item.name}`));
                }

                // Equipment modify
                if (update.item_modify && update.item_modify.length > 0) {
                    const currentEquipment = character.equipment || [];
                    const modifiedEquipment = currentEquipment.map(item => {
                        const modification = update.item_modify.find(mod => mod.name === item.name);
                        if (modification) {
                            showToast(`Item modified: ${modification.name}`);
                            return {
                                ...item,
                                name: modification.new_name || item.name,
                                lore: modification.lore || item.lore
                            };
                        }
                        return item;
                    });

                    updates.character = {
                        ...(updates.character || character),
                        equipment: modifiedEquipment
                    };
                }

                // Clock advancement
                if (update.clocks_advance && update.clocks_advance.length > 0) {
                    const worldClocks = { ...state.worldClocks };
                    const clocks = [...(worldClocks.clocks || [])];

                    update.clocks_advance.forEach(adv => {
                        const clock = clocks.find(c => c.name === adv.name);
                        if (clock) {
                            clock.current = Math.min(clock.segments, (clock.current || 0) + (adv.amount || 1));
                            showToast(`${clock.name} advanced!`);
                        }
                    });

                    updates.worldClocks = { clocks };
                }

                return updates;
            });
        }
        
        async function resetGame() {
            if (!confirm("WARNING: This will wipe your character, story, and world state. This cannot be undone.\n\nAre you sure?")) {
                return;
            }

            showLoading("Resetting game...");

            try {
                gameState.reset();
                location.reload();
            } catch (e) {
                console.error(e);
                alert("Reset Error: " + e.message);
                location.reload();
            }
        }

        async function handleInterludeAction(actionType) {
            const character = gameState.getState().character;
            const cost = 1;

            if ((character.xp || 0) < cost) {
                return window.showError("Insufficient XP", "You need more XP.");
            }

            if (!confirm(`Spend ${cost} XP to perform this action?`)) {
                return;
            }

            showLoading();

            try {
                // Deduct XP
                await gameState.transaction(async (state) => ({
                    character: {
                        ...state.character,
                        xp: state.character.xp - cost
                    }
                }));

                // Call AI with interlude action
                const prompt = `[INTERLUDE ACTION] Player chose: ${actionType}. Narrate the result.`;
                const aiResponse = await callAIGM(prompt);

                if (aiResponse.narrative) {
                    await addMessageToChat('model', aiResponse.narrative);
                }

                if (aiResponse.state_update) {
                    await processStateUpdate(aiResponse.state_update);
                }

                // End interlude if requested
                if (actionType === 'end_interlude') {
                    await gameState.transaction(async (state) => ({
                        gameState: {
                            ...state.gameState,
                            phase: 'adventure'
                        }
                    }));
                }

            } catch(e) {
                window.showError("Interlude Error", e.message);
            } finally {
                hideLoading();
            }
        }

        function hideLoading() { if(ui.loading) ui.loading.style.display = 'none'; }
        function showLoading() { if(ui.loading) ui.loading.style.display = 'flex'; }

        // ===== EXPORT/IMPORT SAVE FUNCTIONS =====

        window.exportSave = function() {
            const saveData = gameState.exportState();
            const blob = new Blob([saveData], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ashlords-save-${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            showToast('Save exported!');
        };

        window.importSave = function() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    const success = gameState.importState(event.target.result);
                    if (success) {
                        showToast('Save imported successfully!');
                        setTimeout(() => location.reload(), 1000);
                    } else {
                        window.showError('Import Failed', 'Invalid save file');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        };

        // ===== DISPLAY FUNCTIONS (Restored from archive) =====

        async function addMessageToChat(role, content) {
            await gameState.transaction(async (state) => {
                const history = [...(state.chatHistory || [])];

                history.push({
                    role,
                    content,
                    timestamp: Date.now(),
                    id: crypto.randomUUID()
                });

                // Keep only last 30 messages
                const trimmed = history.slice(-30);

                return { chatHistory: trimmed };
            });
        }

        function showToast(message, duration = 3000) {
            const toast = document.createElement('div');
            toast.className = 'toast';
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, duration);
        }

        function displayChatHistory(messages) {
            const log = document.getElementById('narrative-log');
            if (!log) return;

            log.innerHTML = '';

            messages.forEach(msg => {
                const bubble = document.createElement('div');
                bubble.className = msg.role === 'user'
                    ? 'narrative-bubble-user'
                    : 'narrative-bubble-model';

                // Parse mechanics blocks
                let content = msg.content;
                if (msg.role === 'model') {
                    content = content.replace(
                        /<mechanics>(.*?)<\/mechanics>/gi,
                        '<div class="mechanics-text">$1</div>'
                    );
                }

                bubble.innerHTML = content;
                log.appendChild(bubble);
            });

            // Scroll to bottom
            log.scrollTop = log.scrollHeight;
        }

        function displayWorldClocks(data) {
            const container = document.getElementById('world-clocks-container');
            if (!container) return;

            const loading = document.getElementById('world-clocks-loading');
            if (loading) loading.style.display = 'none';

            container.innerHTML = '';

            (data.clocks || []).forEach(clock => {
                const clockDiv = document.createElement('div');
                clockDiv.className = 'clock';
                clockDiv.innerHTML = `
                    <div class="clock-face ${clock.current >= clock.segments - 1 ? 'near-full' : ''}"
                         id="clock-${clock.name.replace(/\s+/g, '-')}">
                        ${renderClockSegments(clock.current, clock.segments)}
                    </div>
                    <div class="clock-name">${clock.name}</div>
                    <div class="text-xs text-gray-500 text-center mt-1">${clock.current}/${clock.segments}</div>
                `;
                container.appendChild(clockDiv);
            });
        }

        function renderClockSegments(current, total) {
            let html = '';
            for (let i = 0; i < total; i++) {
                const angle = (360 / total) * i;
                const filled = i < current ? 'filled' : '';
                html += `<div class="clock-segment ${filled}" style="transform: rotate(${angle}deg)"></div>`;
            }
            return html;
        }

        function displayDestinyClock(data) {
            const face = document.getElementById('destiny-clock-face');
            if (!face) return;

            face.innerHTML = renderClockSegments(data.current || 0, data.segments || 8);

            // Update narrative text based on progress
            const narrativeEl = document.getElementById('destiny-narrative');
            if (narrativeEl) {
                const progress = data.current || 0;
                const narratives = [
                    "Your destiny awaits...",
                    "You are nobody... yet.",
                    "People start to notice you.",
                    "Your name is whispered in taverns.",
                    "A legend in the making.",
                    "Your deeds echo across the land.",
                    "Heroes sing of your exploits.",
                    "The world trembles at your name.",
                    "Time to claim your destiny."
                ];
                narrativeEl.textContent = narratives[Math.min(progress, narratives.length - 1)];
            }
        }

        function displayEndgameFront(data) {
            const face = document.getElementById('endgame-front-clock-face');
            if (!face) return;

            const current = data.current || 0;
            const segments = data.segments || 8;

            face.innerHTML = renderClockSegments(current, segments);

            // Pulse animation if near full
            if (current >= segments - 2) {
                face.classList.add('threat-critical');
            } else {
                face.classList.remove('threat-critical');
            }

            // Update name
            const nameEl = document.getElementById('endgame-front-name');
            if (nameEl) {
                nameEl.textContent = data.name || "Unknown Threat";
            }
        }

        function displayQuestProgress(data) {
            const wrapper = document.getElementById('quest-progress-wrapper');
            if (!wrapper) return;

            wrapper.style.display = 'block';

            document.getElementById('quest-title').textContent = data.title || "Quest";
            document.getElementById('quest-chapter').textContent = `Chapter ${data.chapter || 1}`;
            document.getElementById('quest-progress-text').textContent = `${data.progress || 0}/${data.max_progress || 1}`;
            document.getElementById('quest-xp-earned').textContent = `XP Earned: ${data.xp_earned || 0}`;

            const progressPercent = ((data.progress || 0) / (data.max_progress || 1)) * 100;
            document.getElementById('quest-progress-bar').style.width = `${progressPercent}%`;
        }

        function hideQuestProgress() {
            const wrapper = document.getElementById('quest-progress-wrapper');
            if (wrapper) wrapper.style.display = 'none';
        }

        if (document.readyState === 'loading') { document.addEventListener('DOMContentLoaded', init); } else { init(); }
    </script>
</body>
</html>